<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BGlib.be.translators.df_utils.be_utils &mdash; BGlib 0.0.4 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../_static/documentation_options.js?v=8c5712d9"></script>
        <script src="../../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../../../../about.html" />
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            BGlib
          </a>
              <div class="version">
                0.0.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">BGlib</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../about.html">BGlib</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../_autosummary/BGlib.html">BGlib</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/be/index.html">Band Excitation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../notebooks/gmode/index.html">General Mode</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">BGlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">BGlib.be.translators.df_utils.be_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for BGlib.be.translators.df_utils.be_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Tue Jan 05 07:55:56 2016</span>

<span class="sd">@author: Suhas Somnath, Chris Smith, Rama K. Vasudevan</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">path</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">xlrd</span> <span class="k">as</span> <span class="nn">xlreader</span>

<span class="kn">from</span> <span class="nn">sidpy.hdf.hdf_utils</span> <span class="kn">import</span> <span class="n">write_simple_attrs</span><span class="p">,</span> <span class="n">link_h5_objects_as_attrs</span><span class="p">,</span> \
    <span class="n">get_attr</span><span class="p">,</span> <span class="n">get_auxiliary_datasets</span>
<span class="kn">from</span> <span class="nn">pyUSID.processing.comp_utils</span> <span class="kn">import</span> <span class="n">get_available_memory</span><span class="p">,</span> <span class="n">parallel_compute</span>

<span class="kn">from</span> <span class="nn">pyUSID.io.hdf_utils</span> <span class="kn">import</span> <span class="n">find_dataset</span><span class="p">,</span> <span class="n">create_indexed_group</span><span class="p">,</span> \
    <span class="n">write_main_dataset</span><span class="p">,</span> <span class="n">get_unit_values</span>
<span class="kn">from</span> <span class="nn">pyUSID</span> <span class="kn">import</span> <span class="n">Dimension</span>
<span class="kn">from</span> <span class="nn">pyUSID.io.anc_build_utils</span> <span class="kn">import</span> <span class="n">create_spec_inds_from_vals</span>

<span class="kn">from</span> <span class="nn">.histogram</span> <span class="kn">import</span> <span class="n">build_histogram</span>
<span class="kn">from</span> <span class="nn">...analysis.utils.be_sho</span> <span class="kn">import</span> <span class="n">SHOestimateGuess</span>
<span class="kn">from</span> <span class="nn">...viz.be_viz_utils</span> <span class="kn">import</span> <span class="n">plot_1d_spectrum</span><span class="p">,</span> <span class="n">plot_2d_spectrogram</span><span class="p">,</span> \
    <span class="n">plot_histograms</span>

<span class="n">nf32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">({</span><span class="s1">&#39;names&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;super_band&#39;</span><span class="p">,</span> <span class="s1">&#39;inter_bin_band&#39;</span><span class="p">,</span> <span class="s1">&#39;sub_band&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;formats&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">]})</span>


<div class="viewcode-block" id="generate_bipolar_triangular_waveform">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.generate_bipolar_triangular_waveform.html#BGlib.be.translators.df_utils.be_utils.generate_bipolar_triangular_waveform">[docs]</a>
<span class="k">def</span> <span class="nf">generate_bipolar_triangular_waveform</span><span class="p">(</span><span class="n">cycle_pts</span><span class="p">,</span> <span class="n">cycle_frac</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                         <span class="n">amplitude</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cycles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a bi-polar triangular waveform based on basic parameters</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cycle_pts : int</span>
<span class="sd">        Number of parameters in a single cycle</span>
<span class="sd">    cycle_frac : float, optional. Default = 1</span>
<span class="sd">        Fraction of the cycle - ranges as (0, 1]</span>
<span class="sd">    phase : float, optional. Default = 0</span>
<span class="sd">        Phase offset for the waveform. Ranges as [0, 1)</span>
<span class="sd">    amplitude : float, optional. Default = 1</span>
<span class="sd">        Maximum amplitude for the waveform</span>
<span class="sd">    offset : float, optional. Default = 0</span>
<span class="sd">        DC offset for the waveform</span>
<span class="sd">    cycles : int, optional. Default = 1</span>
<span class="sd">        Number of repetitions or cycles</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dc_vec</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Scale the number of points in the cycle by the (inverse of) the fraction</span>
    <span class="n">actual_cycle_pts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cycle_pts</span> <span class="o">//</span> <span class="n">cycle_frac</span><span class="p">)</span>

    <span class="c1"># Build the default bi-polar triangular waveform</span>
    <span class="n">dc_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
        <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">actual_cycle_pts</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
         <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">actual_cycle_pts</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
         <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">actual_cycle_pts</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
         <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">actual_cycle_pts</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)))</span>

    <span class="c1"># Apply phase offset via a roll:</span>
    <span class="n">dc_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">dc_vec</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">phase</span> <span class="o">*</span> <span class="n">actual_cycle_pts</span><span class="p">))</span>

    <span class="c1"># Next truncate by the fraction</span>
    <span class="n">dc_vec</span> <span class="o">=</span> <span class="n">dc_vec</span><span class="p">[:</span><span class="n">cycle_pts</span><span class="p">]</span>

    <span class="c1"># Next, scale by the amplitude:</span>
    <span class="n">dc_vec</span> <span class="o">=</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">dc_vec</span>

    <span class="c1"># Next offset:</span>
    <span class="n">dc_vec</span> <span class="o">+=</span> <span class="n">offset</span>

    <span class="c1"># Finally, tile by the number of cycles</span>
    <span class="n">dc_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">dc_vec</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">cycles</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">dc_vec</span></div>



<div class="viewcode-block" id="infer_bipolar_triangular_fraction_phase">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.infer_bipolar_triangular_fraction_phase.html#BGlib.be.translators.df_utils.be_utils.infer_bipolar_triangular_fraction_phase">[docs]</a>
<span class="k">def</span> <span class="nf">infer_bipolar_triangular_fraction_phase</span><span class="p">(</span><span class="n">slopes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infers the VS cycle fraction and phase when parameters were</span>
<span class="sd">    stored in old mat files</span>

<span class="sd">    Parameters</span>
<span class="sd">    --------------------</span>
<span class="sd">    slopes : list / tuple</span>
<span class="sd">        Array of mean slopes of each fraction of a SINGLE cycle</span>

<span class="sd">    Returns</span>
<span class="sd">    --------------------</span>
<span class="sd">    tuple:</span>
<span class="sd">        fraction : float</span>
<span class="sd">            Fraction of VS cycle</span>
<span class="sd">        phase : float</span>
<span class="sd">            Phase offset for VS cycle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">]):</span>
        <span class="k">return</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">]):</span>
        <span class="k">return</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[:</span><span class="mi">2</span><span class="p">]])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]):</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[:</span><span class="mi">2</span><span class="p">]])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]):</span>
        <span class="k">return</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
        <span class="k">return</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[:</span><span class="mi">3</span><span class="p">]])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">3</span><span class="p">:]]):</span>
        <span class="k">return</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]):</span>
        <span class="k">return</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span>
    <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">_</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[:</span><span class="mi">3</span><span class="p">]])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">3</span><span class="p">:]]):</span>
        <span class="k">return</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.75</span>
    <span class="k">elif</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slopes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span></div>



<div class="viewcode-block" id="flat_parm_dict_to_nested">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.flat_parm_dict_to_nested.html#BGlib.be.translators.df_utils.be_utils.flat_parm_dict_to_nested">[docs]</a>
<span class="k">def</span> <span class="nf">flat_parm_dict_to_nested</span><span class="p">(</span><span class="n">parm_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a nested dictionary of parameters for Band EXcitation from the</span>
<span class="sd">    standard flat dictionary</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parm_dict : dict</span>
<span class="sd">        Dictionary with parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nest_parm_dict : dict</span>
<span class="sd">        Nested dictionary of the same parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">parm_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    for key in keys:</span>
<span class="sd">        print(&#39;{} : {}&#39;.format(key, main_dsets[0].parent.parent.attrs[key]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nest_parm_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;FORC&#39;</span><span class="p">,</span> <span class="s1">&#39;VS&#39;</span><span class="p">,</span> <span class="s1">&#39;grid&#39;</span><span class="p">,</span> <span class="s1">&#39;BE&#39;</span><span class="p">,</span> <span class="s1">&#39;IO&#39;</span><span class="p">,</span> <span class="s1">&#39;File&#39;</span><span class="p">,</span> <span class="s1">&#39;Misc&#39;</span><span class="p">]:</span>
        <span class="n">nest_parm_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="s1">&#39;Misc&#39;</span>
        <span class="n">rem_key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">nest_parm_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rem_key</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">nest_parm_dict</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="n">rem_key</span><span class="p">:</span> <span class="n">parm_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]})</span>
    <span class="k">return</span> <span class="n">nest_parm_dict</span></div>



<div class="viewcode-block" id="remove_non_exist_spec_dim_labs">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.remove_non_exist_spec_dim_labs.html#BGlib.be.translators.df_utils.be_utils.remove_non_exist_spec_dim_labs">[docs]</a>
<span class="k">def</span> <span class="nf">remove_non_exist_spec_dim_labs</span><span class="p">(</span><span class="n">h5_spec_inds</span><span class="p">,</span> <span class="n">h5_spec_vals</span><span class="p">,</span>
                                   <span class="n">h5_meas_grp</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes non-existent spectroscopic dimension name and units from</span>
<span class="sd">    attributes of spectroscopic datasets.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This was written mainly to clean up</span>
<span class="sd">    after the buggy Labview HDF5 acquisition software. This will be used in</span>
<span class="sd">    the LabviewHDF5Patcher Translator</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_spec_inds : h5py.Dataset</span>
<span class="sd">        Dataset containing the spectroscopic indices</span>
<span class="sd">    h5_spec_vals : h5py.Dataset</span>
<span class="sd">        Dataset containing the spectroscopic values</span>
<span class="sd">    h5_meas_grp : h5py.Group</span>
<span class="sd">        Group containing all the parameters for the BE measurement</span>
<span class="sd">    verbose : bool, optional. Default = False</span>
<span class="sd">        Whether or not to print statements aiding in debugging</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">exp_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">h5_spec_inds</span><span class="p">,</span> <span class="n">h5_spec_vals</span><span class="p">,</span> <span class="n">h5_meas_grp</span><span class="p">],</span>
                                   <span class="p">[</span><span class="s1">&#39;h5_spec_inds&#39;</span><span class="p">,</span> <span class="s1">&#39;h5_spec_vals&#39;</span><span class="p">,</span> <span class="s1">&#39;h5_meas_grp&#39;</span><span class="p">],</span>
                                   <span class="p">[</span><span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> should be a </span><span class="si">{}</span><span class="s1">. Provided object was: </span><span class="si">{}</span><span class="s1">&#39;</span>
                            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exp_type</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>

    <span class="n">spec_dim_names</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_spec_inds</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">)</span>
    <span class="n">spec_dim_units</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_spec_inds</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_dim_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_dim_units</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unqeual lengths for the spec dim names and units&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_dim_names</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">h5_spec_inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s1">&#39;extra dimensions in the list of names attributes: </span><span class="si">{}</span><span class="s1"> compared to &#39;</span>
            <span class="s1">&#39;rows in dataset: </span><span class="si">{}</span><span class="s1">&#39;</span>
            <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spec_dim_names</span><span class="p">),</span> <span class="n">h5_spec_inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec_dim_names</span><span class="p">)</span> <span class="o">-</span> <span class="n">h5_spec_inds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s1">&#39;Cannot handle case when more than one dimensions are fake&#39;</span><span class="p">)</span>

    <span class="c1"># Gather basic parameters for each dimension</span>
    <span class="c1"># h5_meas_grp = h5_raw.parent.parent</span>
    <span class="n">field_type</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;VS_measure_in_field_loops&#39;</span><span class="p">)</span>
    <span class="n">num_freq_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;num_bins&#39;</span><span class="p">)</span> <span class="o">/</span>
                        <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;num_UDVS_steps&#39;</span><span class="p">))</span>
    <span class="n">num_fields</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">targ</span> <span class="ow">in</span> <span class="n">field_type</span> <span class="k">for</span> <span class="n">targ</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;in&#39;</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">]]))</span>
    <span class="n">dc_off_steps</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;VS_steps_per_full_cycle&#39;</span><span class="p">)</span>
    <span class="n">num_cycles</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;VS_number_of_cycles&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">num_forc_cycles</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;VS_num_of_FORC_cycles&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># This is named differently in some h5 files</span>
        <span class="n">num_forc_cycles</span> <span class="o">=</span> <span class="n">get_attr</span><span class="p">(</span><span class="n">h5_meas_grp</span><span class="p">,</span> <span class="s1">&#39;VS_num_of_Forc_cycles&#39;</span><span class="p">)</span>

    <span class="n">size_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Frequency&#39;</span><span class="p">:</span> <span class="n">num_freq_bins</span><span class="p">,</span>
                 <span class="s1">&#39;DC_Offset&#39;</span><span class="p">:</span> <span class="n">dc_off_steps</span><span class="p">,</span>
                 <span class="s1">&#39;Field&#39;</span><span class="p">:</span> <span class="n">num_fields</span><span class="p">,</span>
                 <span class="s1">&#39;Cycle&#39;</span><span class="p">:</span> <span class="n">num_cycles</span><span class="p">,</span>
                 <span class="s1">&#39;FORC&#39;</span><span class="p">:</span> <span class="n">num_forc_cycles</span><span class="p">,</span>
                 <span class="p">}</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">size_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> : </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

    <span class="n">matched_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">matched_units</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="n">row_ind</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">dim_name</span><span class="p">,</span> <span class="n">dim_units</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">spec_dim_names</span><span class="p">,</span> <span class="n">spec_dim_units</span><span class="p">):</span>
        <span class="c1"># Pass one row at a time:</span>
        <span class="n">this_dict</span> <span class="o">=</span> <span class="n">get_unit_values</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">h5_spec_inds</span><span class="p">[</span><span class="n">row_ind</span><span class="p">],</span>
                                                   <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">h5_spec_vals</span><span class="p">[</span><span class="n">row_ind</span><span class="p">],</span>
                                                   <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                    <span class="n">is_spec</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_dim_names</span><span class="o">=</span><span class="p">[</span><span class="n">dim_name</span><span class="p">])</span>

        <span class="n">std_dim_name</span> <span class="o">=</span> <span class="n">dim_name</span>
        <span class="k">if</span> <span class="n">dim_name</span> <span class="o">==</span> <span class="s1">&#39;FORC_Cycle&#39;</span><span class="p">:</span>
            <span class="n">std_dim_name</span> <span class="o">=</span> <span class="s1">&#39;FORC&#39;</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">dim_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_dict</span><span class="p">[</span><span class="n">dim_name</span><span class="p">]),</span> <span class="n">size_dict</span><span class="p">[</span><span class="n">std_dim_name</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_dict</span><span class="p">[</span><span class="n">dim_name</span><span class="p">])</span> <span class="o">==</span> <span class="n">size_dict</span><span class="p">[</span><span class="n">std_dim_name</span><span class="p">]:</span>
            <span class="n">row_ind</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">matched_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_name</span><span class="p">)</span>
            <span class="n">matched_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim_units</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">Dimension: &quot;&#39;</span> <span class="o">+</span> <span class="n">dim_name</span> <span class="o">+</span> <span class="s1">&#39;&quot; did not match with what &#39;</span>
                                                  <span class="s1">&#39;was in dataset&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Writing new attributes to spectroscopic datasets&#39;</span><span class="p">)</span>

    <span class="n">new_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">matched_dims</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="n">matched_units</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">h5_dset</span> <span class="ow">in</span> <span class="p">[</span><span class="n">h5_spec_inds</span><span class="p">,</span> <span class="n">h5_spec_vals</span><span class="p">]:</span>
        <span class="n">write_simple_attrs</span><span class="p">(</span><span class="n">h5_dset</span><span class="p">,</span> <span class="n">new_attrs</span><span class="p">)</span></div>



<div class="viewcode-block" id="parmsToDict">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.parmsToDict.html#BGlib.be.translators.df_utils.be_utils.parmsToDict">[docs]</a>
<span class="k">def</span> <span class="nf">parmsToDict</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">parms_to_remove</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translates the parameters in the text file into a dictionary. </span>
<span class="sd">    Also indentifies whether this is a BEPS or BELine dataset.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    filepath : String / Unicode</span>
<span class="sd">        Absolute path of the parameters text or spreadsheet file.</span>
<span class="sd">    parms_to_remove : List of string (Optional)</span>
<span class="sd">        keys that this function should attempt to remove from the dictionary</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    isBEPS : Boolean</span>
<span class="sd">        whether this dataset is BEPS or BE Line.</span>
<span class="sd">    parm_dict : Dictionary</span>
<span class="sd">        experimental parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">filepath</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">):</span>
        <span class="n">file_handle</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">raw_lines</span> <span class="o">=</span> <span class="n">file_handle</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">file_handle</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">raw_lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; : &quot;</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">filepath</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.xls&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">filepath</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.xlsx&#39;</span><span class="p">):</span>
        <span class="n">workbook</span> <span class="o">=</span> <span class="n">xlreader</span><span class="o">.</span><span class="n">open_workbook</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
        <span class="n">worksheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">sheet_by_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">worksheet</span><span class="o">.</span><span class="n">nrows</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">worksheet</span><span class="o">.</span><span class="n">ncols</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">worksheet</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Parameter file not of expected format: text or spreadsheet&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished reading the file&quot;</span><span class="p">)</span>

    <span class="n">is_beps</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">parm_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;File_&#39;</span>
    <span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="c1"># Ignore the parameters describing the GUI choices</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;Multi_&#39;</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Check if the line is a group header or parameter/value pair</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Get the current name/value pair, and clean up the name</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;# &#39;</span><span class="p">,</span> <span class="s1">&#39;num_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="s1">&#39;num_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Rename specific parameters</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;1_mode&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;mode&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;IO_rate&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;IO_rate_[Hz]&#39;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1E6</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># very rare</span>
                    <span class="c1"># let it be a string</span>
                    <span class="k">pass</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;AO_range&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;AO_range_[V]&#39;</span>
                <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;AO_amplifier&#39;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;cycle_time[s]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cycle_time_[s]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;FORC_V_high1[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;FORC_V_high1_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;FORC_V_high2[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;FORC_V_high2_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;FORC_V_low1[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;FORC_V_low1_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;FORC_V_low2[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;FORC_V_low2_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;amplitude[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;amplitude_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;offset[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;offset_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;set_pulst_amplitude[V]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;set_pulst_amplitude_[V]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;set_pulst_duration[s]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;set_pulst_duration_[s]&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;step_edge_smoothing[s]&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;step_edge_smoothing_[s]&#39;</span>

            <span class="c1"># Append the prefix to the name</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

            <span class="c1"># Write parameter to parm_dict</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">parm_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
                    <span class="n">parm_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">parm_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Change the parameter prefix to the new one from the group header</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span>

            <span class="c1"># Check if there are VS Parameters.  Set isBEPS to true if so.</span>
            <span class="n">is_beps</span> <span class="o">=</span> <span class="n">is_beps</span> <span class="ow">or</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s1">&#39;VS_&#39;</span>

    <span class="k">if</span> <span class="n">is_beps</span><span class="p">:</span>
        <span class="n">useless_parms</span> <span class="o">=</span> \
            <span class="p">[</span><span class="s1">&#39;Multi_1_BE_response_spectra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_2_BE_amplitude_spectra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_3_BE_phase_spectra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_4_BE_response_spectrogram&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_5_BE_amplitude_spectrogram&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_6_BE_phase_spectrogram&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_7_VS_response_loops&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_8_VS_amplitude_loops&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_9_VS_phase_loops&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_10_topography&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_11_mean_channel_2&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">useless_parms</span> <span class="o">=</span> \
            <span class="p">[</span><span class="s1">&#39;Multi_1_BE_response_spectra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_2_BE_amplitude_spectra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_3_BE_phase_spectra&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_4_BE_response_spectrogram&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_5_BE_amplitude_spectrogram&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_6_BE_phase_spectrogram&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_7_amplitude_map&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_8_resonance_map&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_9_Q_map&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_10_phase_map&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_11_topography&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_12_AI_time_domain&#39;</span><span class="p">,</span>
             <span class="s1">&#39;Multi_13_AI_Fourier_amplitude&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished parsing the text pairs. isBEPS = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">is_beps</span><span class="p">))</span>

    <span class="n">useless_parms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parms_to_remove</span><span class="p">)</span>

    <span class="c1"># Now remove the list of useless parameters:</span>
    <span class="k">for</span> <span class="n">uparm</span> <span class="ow">in</span> <span class="n">useless_parms</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">parm_dict</span><span class="p">[</span><span class="n">uparm</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># warn(&#39;Parameter to be deleted does not exist&#39;)</span>
            <span class="k">pass</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span>
    <span class="k">del</span> <span class="n">uparm</span><span class="p">,</span> <span class="n">useless_parms</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished removing useless parameters&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_beps</span><span class="p">:</span>
        <span class="c1"># fix the DC type in the parms:</span>
        <span class="k">if</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_measure_in_field_loops&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;out-of-field only&#39;</span><span class="p">:</span>
            <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_measure_in_field_loops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;out-of-field&#39;</span>
        <span class="k">elif</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_measure_in_field_loops&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;in-field only&#39;</span><span class="p">:</span>
            <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_measure_in_field_loops&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;in-field&#39;</span>

    <span class="k">return</span> <span class="n">is_beps</span><span class="p">,</span> <span class="n">parm_dict</span></div>



<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="requires_conjugate">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.requires_conjugate.html#BGlib.be.translators.df_utils.be_utils.requires_conjugate">[docs]</a>
<span class="k">def</span> <span class="nf">requires_conjugate</span><span class="p">(</span><span class="n">chosen_spectra</span><span class="p">,</span> <span class="n">default_q</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines whether or not the conjugate of the data needs to be taken based on the quality factor</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chosen_spectra : 2D complex numpy array</span>
<span class="sd">        N random spectra arranged as [instance, frequency]</span>
<span class="sd">    default_q : unsigned int, Optional</span>
<span class="sd">        Default value of Q factor that the SHO guess function results in for poor guesses</span>
<span class="sd">    cores : uint, Optional</span>
<span class="sd">        Number of CPU cores to use for the SHO guess.</span>
<span class="sd">        Default = None - ask pyUSID.processing.comp_utils.recommend_cpu_cores for automatic assignment</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    do_conjugate : Boolean</span>
<span class="sd">        Whether or not to take the conjugate of the data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Do the SHO Guess for each of these</span>
    <span class="n">sho_guess</span> <span class="o">=</span> <span class="n">parallel_compute</span><span class="p">(</span><span class="n">chosen_spectra</span><span class="p">,</span> <span class="n">SHOestimateGuess</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">cores</span><span class="p">,</span>
                                 <span class="n">func_args</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">chosen_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                            <span class="mi">5</span><span class="p">])</span>

    <span class="n">q_results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sho_guess</span><span class="p">)[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">good_q</span> <span class="o">=</span> <span class="n">q_results</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">q_results</span> <span class="o">!=</span> <span class="n">default_q</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">good_q</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span></div>



<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="getSpectroscopicParmLabel">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getSpectroscopicParmLabel.html#BGlib.be.translators.df_utils.be_utils.getSpectroscopicParmLabel">[docs]</a>
<span class="k">def</span> <span class="nf">getSpectroscopicParmLabel</span><span class="p">(</span><span class="n">expt_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the label for the spectroscopic parameter in the plot group. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    expt_type : str</span>
<span class="sd">        Type of the experiment - found in the parms.txt file</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    str</span>
<span class="sd">        label for the spectroscopic parameter axis in the plot</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">expt_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;DC modulation mode&#39;</span><span class="p">,</span> <span class="s1">&#39;current mode&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="s1">&#39;DC Bias&#39;</span>
    <span class="k">elif</span> <span class="n">expt_type</span> <span class="o">==</span> <span class="s1">&#39;AC modulation mode with time reversal&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;AC amplitude&#39;</span>
    <span class="k">return</span> <span class="s1">&#39;User Defined&#39;</span></div>



<div class="viewcode-block" id="normalizeBEresponse">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.normalizeBEresponse.html#BGlib.be.translators.df_utils.be_utils.normalizeBEresponse">[docs]</a>
<span class="k">def</span> <span class="nf">normalizeBEresponse</span><span class="p">(</span><span class="n">spectrogram_mat</span><span class="p">,</span> <span class="n">FFT_BE_wave</span><span class="p">,</span> <span class="n">harmonic</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function normalizes the BE waveform to correct the phase by diving by the excitation</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    spectrogram_mat : 2D complex numpy array</span>
<span class="sd">        BE response arranged as [bins, steps]</span>
<span class="sd">    FFT_BE_wave : 1D complex numpy array</span>
<span class="sd">        FFT of the BE waveform at the appropriate bins. Number of bins must match with spectrogram_mat</span>
<span class="sd">    harmonic : unsigned int</span>
<span class="sd">        nth harmonic of the excitation waveform</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrogram_mat : 2D complex numpy array</span>
<span class="sd">        Normalized BE response spectrogram</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BE_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">FFT_BE_wave</span><span class="p">))</span>
    <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">harmonic</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">BE_wave</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">harmonic</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">BE_wave</span> <span class="o">**</span> <span class="mi">3</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">harmonic</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning these high harmonics are not supported in translator.&quot;</span><span class="p">)</span>

    <span class="c1"># Generate transfer functions</span>
    <span class="n">F_AO_spectrogram</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">FFT_BE_wave</span> <span class="o">/</span> <span class="n">scaling_factor</span><span class="p">,</span> <span class="p">[</span><span class="n">spectrogram_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># Divide by transfer function</span>
    <span class="n">spectrogram_mat</span> <span class="o">=</span> <span class="n">spectrogram_mat</span> <span class="o">/</span> <span class="n">F_AO_spectrogram</span>

    <span class="k">return</span> <span class="n">spectrogram_mat</span></div>



<div class="viewcode-block" id="generatePlotGroups">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.generatePlotGroups.html#BGlib.be.translators.df_utils.be_utils.generatePlotGroups">[docs]</a>
<span class="k">def</span> <span class="nf">generatePlotGroups</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">mean_resp</span><span class="p">,</span> <span class="n">folder_path</span><span class="p">,</span> <span class="n">basename</span><span class="p">,</span> <span class="n">max_resp</span><span class="o">=</span><span class="p">[],</span> <span class="n">min_resp</span><span class="o">=</span><span class="p">[],</span>
                       <span class="n">max_mem_mb</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">spec_label</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span>
                       <span class="n">show_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_plots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_histogram</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the spatially averaged datasets for the given raw dataset. </span>
<span class="sd">    The averaged datasets are necessary for quick visualization of the quality of data. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_main : H5 reference</span>
<span class="sd">        to the main dataset</span>
<span class="sd">    mean_resp : 1D numpy array</span>
<span class="sd">        spatially averaged amplitude</span>
<span class="sd">    folder_path : String</span>
<span class="sd">        Absolute path of the data folder</span>
<span class="sd">    basename : String</span>
<span class="sd">        base name of the dataset</span>
<span class="sd">    max_resp : 1D numpy array</span>
<span class="sd">        Maximum amplitude for all pixels</span>
<span class="sd">    min_resp : 1D numpy array</span>
<span class="sd">        Minimum amplitude for all pixels</span>
<span class="sd">    max_mem_mb : Unisigned integer</span>
<span class="sd">        Maximum memory that can be used for generating histograms</span>
<span class="sd">    spec_label : String</span>
<span class="sd">        Parameter that is varying</span>
<span class="sd">    show_plots : (optional) Boolean</span>
<span class="sd">        Whether or not to show plots</span>
<span class="sd">    save_plots : (optional) Boolean</span>
<span class="sd">        Whether or not to save generated plots</span>
<span class="sd">    do_histogram : Boolean (Optional. Default = False)</span>
<span class="sd">        Whether or not to generate hisograms. </span>
<span class="sd">        Caution - Histograms can take a fair amount of time to compute.</span>
<span class="sd">    debug : Boolean, Optional</span>
<span class="sd">        If True, then extra debug statements are printed.</span>
<span class="sd">        Default False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Too</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span>
    <span class="n">h5_f</span> <span class="o">=</span> <span class="n">h5_main</span><span class="o">.</span><span class="n">file</span>

    <span class="n">grp</span> <span class="o">=</span> <span class="n">h5_main</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">h5_freq</span> <span class="o">=</span> <span class="n">grp</span><span class="p">[</span><span class="s1">&#39;Bin_Frequencies&#39;</span><span class="p">]</span>
    <span class="n">UDVS</span> <span class="o">=</span> <span class="n">grp</span><span class="p">[</span><span class="s1">&#39;UDVS&#39;</span><span class="p">]</span>
    <span class="n">spec_inds</span> <span class="o">=</span> <span class="n">h5_main</span><span class="o">.</span><span class="n">h5_spec_inds</span>
    <span class="n">UDVS_inds</span> <span class="o">=</span> <span class="n">grp</span><span class="p">[</span><span class="s1">&#39;UDVS_Indices&#39;</span><span class="p">]</span>
    <span class="n">spec_vals</span> <span class="o">=</span> <span class="n">h5_main</span><span class="o">.</span><span class="n">h5_spec_vals</span>
    <span class="n">spec_dim_labs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_attr</span><span class="p">(</span><span class="n">spec_inds</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">))</span>

    <span class="c1">#     std_cols = [&#39;wave_type&#39;,&#39;Frequency&#39;,&#39;DC_Offset&#39;,&#39;wave_mod&#39;,&#39;AC_Amplitude&#39;,&#39;dc_offset&#39;,&#39;ac_amplitude&#39;]</span>

    <span class="n">col_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_attr</span><span class="p">(</span><span class="n">UDVS</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        No plot groups are defined in the UDVS table.</span>
<span class="sd">        All plot group datasets will be written to the </span>
<span class="sd">        Channel group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span>

    <span class="c1"># Removing the standard columns</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">get_attr</span><span class="p">(</span><span class="n">UDVS</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">)[</span><span class="mi">5</span><span class="p">:])</span>

    <span class="c1">#     col_names = [col for col in col_names if col not in std_cols + ignore_plot_groups]</span>

    <span class="n">freq_inds</span> <span class="o">=</span> <span class="n">spec_inds</span><span class="p">[</span><span class="n">spec_dim_labs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">col_names</span><span class="p">:</span>

        <span class="c1"># Make sure the column name is a regular Python string</span>
        <span class="n">col_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>

        <span class="n">ref</span> <span class="o">=</span> <span class="n">UDVS</span><span class="o">.</span><span class="n">regionref</span><span class="p">[:,</span> <span class="n">col_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col_name</span><span class="p">)]</span>
        <span class="c1"># ref = UDVS.attrs[col_name]</span>
        <span class="c1"># Make sure we&#39;re actually dealing with a reference of some type</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">RegionReference</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># 4. Access that column of the data through region reference</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">UDVS</span><span class="p">[</span><span class="n">ref</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">udvs_inds</span> <span class="o">=</span> <span class="n">UDVS_inds</span><span class="p">[()]</span>
        <span class="n">step_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">udvs_inds</span> <span class="o">==</span> <span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">step_inds</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">:</span>
            <span class="c1"># dtype = Object</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;step indices looked odd. Trying to fix..&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="c1"># Every alternate element in the array is empty.</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">step_inds</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">step_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="n">step_inds</span> <span class="o">=</span> <span class="n">step_inds</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;selected_UDVS_steps = UDVS[ref]</span>
<span class="sd">        selected_UDVS_steps = selected_UDVS_steps[np.isfinite(selected_UDVS_steps)]&quot;&quot;&quot;</span>

        <span class="p">(</span><span class="n">step_averaged_vec</span><span class="p">,</span> <span class="n">mean_spec</span><span class="p">)</span> <span class="o">=</span> <span class="n">reshape_mean_data</span><span class="p">(</span><span class="n">spec_inds</span><span class="p">,</span> <span class="n">step_inds</span><span class="p">,</span> <span class="n">mean_resp</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Need to account for cases with multiple excitation waveforms</span>
<span class="sd">        This will affect the frequency indices / values</span>
<span class="sd">        We are assuming that there is only one excitation waveform per plot group</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freq_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">freq_inds</span><span class="p">[</span><span class="n">step_inds</span><span class="p">])</span>
        <span class="n">freq_vec</span> <span class="o">=</span> <span class="n">h5_freq</span><span class="p">[()][</span><span class="n">freq_slice</span><span class="p">]</span>

        <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_slice</span><span class="p">)</span>  <span class="c1"># int(len(freq_inds)/len(UDVS[ref]))</span>
        <span class="n">pg_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">UDVS</span><span class="p">[</span><span class="n">ref</span><span class="p">],</span> <span class="n">num_bins</span><span class="p">)</span>

        <span class="n">plot_grp</span> <span class="o">=</span> <span class="n">create_indexed_group</span><span class="p">(</span><span class="n">grp</span><span class="p">,</span> <span class="s1">&#39;Spatially_Averaged_Plot_Group&#39;</span><span class="p">)</span>
        <span class="n">write_simple_attrs</span><span class="p">(</span><span class="n">plot_grp</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;Name&#39;</span><span class="p">:</span> <span class="n">col_name</span><span class="p">})</span>

        <span class="n">h5_mean_spec</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Mean_Spectrogram&#39;</span><span class="p">,</span>
                                               <span class="n">data</span><span class="o">=</span><span class="n">mean_spec</span><span class="p">,</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        <span class="n">h5_step_avg</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Step_Averaged_Response&#39;</span><span class="p">,</span>
                                              <span class="n">data</span><span class="o">=</span><span class="n">step_averaged_vec</span><span class="p">,</span>
                                              <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
        <span class="c1"># cannot assume that this is DC offset, could be AC amplitude....</span>
        <span class="n">h5_spec_parm</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Spectroscopic_Parameter&#39;</span><span class="p">,</span>
                                               <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pg_data</span><span class="p">[</span><span class="n">step_inds</span><span class="p">]),</span>
                                               <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">write_simple_attrs</span><span class="p">(</span><span class="n">h5_spec_parm</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">spec_label</span><span class="p">})</span>
        <span class="n">h5_freq_vec</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Bin_Frequencies&#39;</span><span class="p">,</span>
                                          <span class="n">data</span><span class="o">=</span><span class="n">freq_vec</span><span class="p">,</span>
                                          <span class="n">dtype</span><span class="o">=</span><span class="n">h5_freq</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Linking the datasets with the frequency and the spectroscopic variable:</span>
        <span class="n">link_h5_objects_as_attrs</span><span class="p">(</span><span class="n">h5_mean_spec</span><span class="p">,</span> <span class="p">[</span><span class="n">h5_spec_parm</span><span class="p">,</span> <span class="n">h5_freq_vec</span><span class="p">])</span>
        <span class="n">link_h5_objects_as_attrs</span><span class="p">(</span><span class="n">h5_step_avg</span><span class="p">,</span> <span class="p">[</span><span class="n">h5_freq_vec</span><span class="p">])</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create Region Reference for the plot group in the Raw_Data, Spectroscopic_Indices </span>
<span class="sd">        and Spectroscopic_Values Datasets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">raw_ref</span> <span class="o">=</span> <span class="n">h5_main</span><span class="o">.</span><span class="n">regionref</span><span class="p">[:,</span> <span class="n">step_inds</span><span class="p">]</span>
        <span class="n">spec_inds_ref</span> <span class="o">=</span> <span class="n">spec_inds</span><span class="o">.</span><span class="n">regionref</span><span class="p">[:,</span> <span class="n">step_inds</span><span class="p">]</span>
        <span class="n">spec_vals_ref</span> <span class="o">=</span> <span class="n">spec_vals</span><span class="o">.</span><span class="n">regionref</span><span class="p">[:,</span> <span class="n">step_inds</span><span class="p">]</span>

        <span class="n">ref_name</span> <span class="o">=</span> <span class="n">col_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_Plot_Group&#39;</span>
        <span class="n">h5_main</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_ref</span>
        <span class="n">spec_inds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec_inds_ref</span>
        <span class="n">spec_vals</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec_vals_ref</span>

        <span class="n">h5_f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">do_histogram</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Build the histograms for the current plot group</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">BEHistogram</span><span class="p">()</span>
            <span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_labels</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">hist_indices_labels</span> <span class="o">=</span> \
                <span class="n">hist</span><span class="o">.</span><span class="n">buildPlotGroupHist</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">step_inds</span><span class="p">,</span> <span class="n">max_response</span><span class="o">=</span><span class="n">max_resp</span><span class="p">,</span>
                                        <span class="n">min_response</span><span class="o">=</span><span class="n">min_resp</span><span class="p">,</span> <span class="n">max_mem_mb</span><span class="o">=</span><span class="n">max_mem_mb</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">)</span>

            <span class="n">hist_grp</span> <span class="o">=</span> <span class="n">create_indexed_group</span><span class="p">(</span><span class="n">plot_grp</span><span class="p">,</span> <span class="s1">&#39;Histogram&#39;</span><span class="p">)</span>

            <span class="n">hist_spec_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">hist_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">hist_ind</span><span class="p">,</span> <span class="n">hist_dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hist_labels</span><span class="p">):</span>
                <span class="n">hist_spec_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Dimension</span><span class="p">(</span><span class="n">hist_dim</span><span class="p">,</span>
                                                <span class="n">hist_units</span><span class="p">[</span><span class="n">hist_ind</span><span class="p">],</span>
                                                <span class="n">hist_indices</span><span class="p">[</span><span class="n">hist_ind</span><span class="p">]))</span>

            <span class="n">h5_hist</span> <span class="o">=</span> <span class="n">write_main_dataset</span><span class="p">(</span><span class="n">hist_grp</span><span class="p">,</span> <span class="n">hist_mat</span><span class="p">,</span> <span class="s1">&#39;Histograms&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;Counts&#39;</span><span class="p">,</span> <span class="s1">&#39;a.u.&#39;</span><span class="p">,</span>
                                         <span class="kc">None</span><span class="p">,</span> <span class="n">hist_spec_dims</span><span class="p">,</span>
                                         <span class="n">h5_pos_inds</span><span class="o">=</span><span class="n">h5_main</span><span class="o">.</span><span class="n">h5_pos_inds</span><span class="p">,</span> <span class="n">h5_pos_vals</span><span class="o">=</span><span class="n">h5_main</span><span class="o">.</span><span class="n">h5_pos_vals</span><span class="p">,</span>
                                         <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                                         <span class="n">chunking</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hist_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                         <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Write the min and max response vectors so that histograms can be generated later.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">h5_max_resp</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Max_Response&#39;</span><span class="p">,</span>
                                                  <span class="n">data</span><span class="o">=</span><span class="n">max_resp</span><span class="p">)</span>
            <span class="n">h5_min_resp</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Min_Response&#39;</span><span class="p">,</span>
                                                  <span class="n">data</span><span class="o">=</span><span class="n">min_resp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">save_plots</span> <span class="ow">or</span> <span class="n">show_plots</span><span class="p">:</span>
            <span class="n">fig_title</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">grp</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">col_name</span><span class="p">])</span>

            <span class="n">fig_1d</span><span class="p">,</span> <span class="n">axes_1d</span> <span class="o">=</span> <span class="n">plot_1d_spectrum</span><span class="p">(</span><span class="n">step_averaged_vec</span><span class="p">,</span> <span class="n">freq_vec</span><span class="p">,</span> <span class="n">fig_title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">save_plots</span><span class="p">:</span>
                <span class="n">path_1d</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">basename</span> <span class="o">+</span> <span class="s1">&#39;_Step_Avg_&#39;</span> <span class="o">+</span> <span class="n">fig_title</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="n">path_2d</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">basename</span> <span class="o">+</span> <span class="s1">&#39;_Mean_Spec_&#39;</span> <span class="o">+</span> <span class="n">fig_title</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>
                <span class="n">path_hist</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">basename</span> <span class="o">+</span> <span class="s1">&#39;_Histograms_&#39;</span> <span class="o">+</span> <span class="n">fig_title</span> <span class="o">+</span> <span class="s1">&#39;.png&#39;</span><span class="p">)</span>

                <span class="n">fig_1d</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path_1d</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_spec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fig_2d</span><span class="p">,</span> <span class="n">axes_2d</span> <span class="o">=</span> <span class="n">plot_2d_spectrogram</span><span class="p">(</span><span class="n">mean_spec</span><span class="p">,</span> <span class="n">freq_vec</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">fig_title</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">save_plots</span><span class="p">:</span>
                    <span class="n">fig_2d</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path_2d</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">do_histogram</span><span class="p">:</span>
                <span class="n">plot_histograms</span><span class="p">(</span><span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">grp</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">figure_path</span><span class="o">=</span><span class="n">path_hist</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">show_plots</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

            <span class="c1"># print(&#39;Generated spatially average data for group: %s&#39; %(col_name))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Completed generating spatially averaged plot groups&#39;</span><span class="p">)</span></div>



<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="reshape_mean_data">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.reshape_mean_data.html#BGlib.be.translators.df_utils.be_utils.reshape_mean_data">[docs]</a>
<span class="k">def</span> <span class="nf">reshape_mean_data</span><span class="p">(</span><span class="n">spec_inds</span><span class="p">,</span> <span class="n">step_inds</span><span class="p">,</span> <span class="n">mean_resp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in the mean data vector and rearranges that data according to </span>
<span class="sd">    plot group as [step number,bins]</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    spec_inds : 2D numpy array</span>
<span class="sd">        UDVS_Indices as a 2D mat</span>
<span class="sd">    step_inds : 1D numpy array or list</span>
<span class="sd">        UDVS step indices corresponding to this plot group</span>
<span class="sd">    mean_resp : 1D numpy complex array</span>
<span class="sd">        position averaged BE data</span>
<span class="sd">            </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    step_averaged_vec : 1D complex numpy array</span>
<span class="sd">        Mean (position averaged) spectrogram averaged over the UDVS steps as well</span>
<span class="sd">    mean_spectrogram : 2D complex numpy array</span>
<span class="sd">        Position averaged data arranged as [step number,bins]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spec_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">step_inds</span><span class="p">]))</span>
    <span class="c1"># Stephen says that we can assume that the number of bins will NOT change in a plot group</span>
    <span class="n">mean_spectrogram</span> <span class="o">=</span> <span class="n">mean_resp</span><span class="p">[</span><span class="n">step_inds</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">)</span>

    <span class="n">step_averaged_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mean_spectrogram</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">step_averaged_vec</span><span class="p">,</span> <span class="n">mean_spectrogram</span></div>



<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="visualize_plot_groups">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.visualize_plot_groups.html#BGlib.be.translators.df_utils.be_utils.visualize_plot_groups">[docs]</a>
<span class="k">def</span> <span class="nf">visualize_plot_groups</span><span class="p">(</span><span class="n">h5_filepath</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualizes the plot groups present in the provided BE data file</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_filepath : String / Uniciode</span>
<span class="sd">        Absolute path of the h5 file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5f</span><span class="p">:</span>
        <span class="n">expt_type</span> <span class="o">=</span> <span class="n">h5f</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data_type&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expt_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;BEPSData&#39;</span><span class="p">,</span> <span class="s1">&#39;BELineData&#39;</span><span class="p">]:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Invalid data format&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">grp_name</span> <span class="ow">in</span> <span class="n">h5f</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">h5f</span><span class="p">[</span><span class="n">grp_name</span><span class="p">][</span><span class="s1">&#39;Channel_000&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">plt_grp_name</span> <span class="ow">in</span> <span class="n">grp</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">plt_grp_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Spatially_Averaged_Plot_Group_&#39;</span><span class="p">):</span>
                    <span class="n">plt_grp</span> <span class="o">=</span> <span class="n">grp</span><span class="p">[</span><span class="n">plt_grp_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">expt_type</span> <span class="o">==</span> <span class="s1">&#39;BEPSData&#39;</span><span class="p">:</span>
                        <span class="n">spect_data</span> <span class="o">=</span> <span class="n">plt_grp</span><span class="p">[</span><span class="s1">&#39;Mean_Spectrogram&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
                        <span class="n">_</span> <span class="o">=</span> <span class="n">plot_2d_spectrogram</span><span class="p">(</span><span class="n">spect_data</span><span class="p">,</span> <span class="n">plt_grp</span><span class="p">[</span><span class="s1">&#39;Bin_Frequencies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                <span class="n">title</span><span class="o">=</span><span class="n">plt_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">])</span>
                    <span class="n">step_avg_data</span> <span class="o">=</span> <span class="n">plt_grp</span><span class="p">[</span><span class="s1">&#39;Step_Averaged_Response&#39;</span><span class="p">]</span>
                    <span class="n">_</span> <span class="o">=</span> <span class="n">plot_1d_spectrum</span><span class="p">(</span><span class="n">step_avg_data</span><span class="p">,</span> <span class="n">plt_grp</span><span class="p">[</span><span class="s1">&#39;Bin_Frequencies&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">plt_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">])</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">hist_data</span> <span class="o">=</span> <span class="n">plt_grp</span><span class="p">[</span><span class="s1">&#39;Histograms&#39;</span><span class="p">]</span>
                        <span class="n">hist_bins</span> <span class="o">=</span> <span class="n">plt_grp</span><span class="p">[</span><span class="s1">&#39;Histograms_Indicies&#39;</span><span class="p">]</span>
                        <span class="n">plot_histograms</span><span class="p">(</span><span class="n">hist_data</span><span class="p">,</span> <span class="n">hist_bins</span><span class="p">,</span> <span class="n">plt_grp</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">])</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>



<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="trimUDVS">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.trimUDVS.html#BGlib.be.translators.df_utils.be_utils.trimUDVS">[docs]</a>
<span class="k">def</span> <span class="nf">trimUDVS</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span><span class="p">,</span> <span class="n">target_col_names</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes unused (typically default) plot groups</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    udvs_mat : 2D numpy array</span>
<span class="sd">        UDVS table arranged as [steps, col]</span>
<span class="sd">    udvs_labs : list of strings</span>
<span class="sd">        Column names of the UDVS table</span>
<span class="sd">    udvs_units : list of strings</span>
<span class="sd">        Units for the columns of the UDVS table</span>
<span class="sd">    target_col_names : list of strings</span>
<span class="sd">        Column names that need to be removed</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    udvs_mat : 2D numpy array</span>
<span class="sd">        Truncated UDVS table</span>
<span class="sd">    udvs_labs : list of strings </span>
<span class="sd">        Truncated list of UDVS column names</span>
<span class="sd">    udvs_units : list of strings</span>
<span class="sd">        Truncated list of UDVS column units</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Delete UDVS rows which are zeros in the very end:</span>
    <span class="c1"># Look at the first column - UDVS steps</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Found zeros at the bottom of the UDVS table. Only keeping the &#39;</span>
             <span class="s1">&#39;first </span><span class="si">{}</span><span class="s1"> rows&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">udvs_mat</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="p">[:</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_col_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">udvs_mat</span><span class="p">,</span> <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">udvs_labs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">udvs_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Error: Incompatible UDVS matrix and labels. Not truncating!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">udvs_mat</span><span class="p">,</span> <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span>

    <span class="c1"># First figure out the column indices</span>
    <span class="n">col_inds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">found_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">target_col_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">udvs_col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">udvs_labs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">udvs_col</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="n">col_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="n">found_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">udvs_col</span><span class="p">)</span>
                <span class="k">break</span>
    <span class="n">col_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">col_inds</span><span class="p">))</span>

    <span class="c1"># Now remove from the labels and the matrix</span>
    <span class="n">udvs_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">col_inds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># col_inds.sort(reverse=True)</span>
    <span class="p">[</span><span class="n">udvs_units</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_inds</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">udvs_labs</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">udvs_labs</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">found_cols</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">udvs_mat</span><span class="p">,</span> <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span></div>



<div class="viewcode-block" id="createSpecVals">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.createSpecVals.html#BGlib.be.translators.df_utils.be_utils.createSpecVals">[docs]</a>
<span class="k">def</span> <span class="nf">createSpecVals</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span> <span class="n">parm_dict</span><span class="p">,</span>
                   <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function will determine the proper Spectroscopic Value array for the </span>
<span class="sd">    dataset</span>
<span class="sd">    </span>
<span class="sd">    Chris Smith -- csmith55@utk.edu</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    udvs_mat : numpy array </span>
<span class="sd">        UDVS table from dataset</span>
<span class="sd">    spec_inds : numpy array </span>
<span class="sd">        Spectroscopic Indices table from dataset</span>
<span class="sd">    bin_freqs : numpy array </span>
<span class="sd">        Bin frequencies</span>
<span class="sd">    bin_wfm_type : numpy array </span>
<span class="sd">        waveform type for each frequency index</span>
<span class="sd">    parm_dict : dictionary</span>
<span class="sd">        parameters for dataset</span>
<span class="sd">    udvs_labs : list of strings</span>
<span class="sd">        labels for the columns of the UDVS matrix</span>
<span class="sd">    udvs_units : list of strings</span>
<span class="sd">        units for the columns of the UDVS matrix</span>
<span class="sd">    verbose : bool, optional. Default = False</span>
<span class="sd">        Whether or not to print debugging print statements</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    ds_spec_val_mat : numpy array </span>
<span class="sd">        Spectroscopic Values table</span>
<span class="sd">    ds_spec_val_labs : list of strings</span>
<span class="sd">        names of the columns of the Spectroscopic Values table</span>
<span class="sd">    ds_spec_val_units : list of strings</span>
<span class="sd">        units of the columns of the Spectroscopic Values table</span>
<span class="sd">    ds_spec_val_labs_names : list of Strings</span>
<span class="sd">        labels with the names of their parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__FindSpecValIndices</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span> <span class="n">usr_defined</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function finds the Spectroscopic Values associated with the dataset that</span>
<span class="sd">        have more than one unique value</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        udvs_mat : numpy array containing the UDVS table</span>
<span class="sd">        spec_inds : numpy array contain Spectroscopic indices table</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iSpec_var : integer array holding column indices in UDVS that change</span>
<span class="sd">        ds_spec_val_mat : array holding all spectral values for columns in iSpec_var</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">udvs_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;step_num&#39;</span><span class="p">,</span> <span class="s1">&#39;dc_offset&#39;</span><span class="p">,</span> <span class="s1">&#39;ac_ampli&#39;</span><span class="p">,</span> <span class="s1">&#39;wave_type&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;wave_mod&#39;</span><span class="p">,</span> <span class="s1">&#39;in-field&#39;</span><span class="p">,</span> <span class="s1">&#39;out-of-field&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;__FindSpecValIndices:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;UDVS matrix of shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">udvs_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;spec_inds of shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">spec_inds</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">udvs_cols</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ud_row</span> <span class="ow">in</span> <span class="n">udvs_mat</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{:04.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ud_row</span><span class="p">]))</span>
            <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>  <span class="c1"># Turn this off if necessary</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">spec_inds</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;spec_inds[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        icheck is an array containing all UDVS steps which should be checked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">icheck</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spec_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;UDVS steps that will be checked: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">icheck</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">icheck</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No row in the spectroscopic indices varied.</span><span class="se">\n</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;Cannot build spectroscopic datasets further&#39;</span><span class="p">)</span>

        <span class="c1"># Copy even step values of DC_offset into odd steps</span>
        <span class="n">UDVS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">usr_defined</span><span class="p">:</span>
            <span class="n">DC</span> <span class="o">=</span> <span class="n">UDVS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">DC</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">DC</span><span class="p">[</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">DC</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>
            <span class="n">UDVS</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">DC</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep only the UDVS values for steps which we care about and the </span>
<span class="sd">        first 5 columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">UDVS</span> <span class="o">=</span> <span class="n">UDVS</span><span class="p">[</span><span class="n">icheck</span><span class="p">,</span> <span class="p">:</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">udvs_cols</span> <span class="o">=</span> <span class="n">udvs_cols</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span>
        <span class="c1">#         UDVS = np.array([UDVS[i] for i in icheck])</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;UDVS matrix after down-selecting rows: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">UDVS</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">udvs_cols</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ud_row</span> <span class="ow">in</span> <span class="n">UDVS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{:04.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ud_row</span><span class="p">]))</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transpose UDVS for ease of looping later on and store the number of steps</span>
<span class="sd">        as num_cols</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">UDVS</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the iSpec_var as an empty array.  It will store the index of the </span>
<span class="sd">        UDVS label for any column which has more than one unique value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iSpec_var</span> <span class="o">=</span> <span class="p">[]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over all columns in udvs_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">col_ind</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_cols</span><span class="p">),</span> <span class="n">udvs_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Find all unique values in the current column</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">toosmall</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">UDVS</span><span class="p">[:,</span> <span class="n">col_ind</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1E-5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">UDVS</span><span class="p">[</span><span class="n">toosmall</span><span class="p">,</span> <span class="n">col_ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">uvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">UDVS</span><span class="p">[:,</span> <span class="n">col_ind</span><span class="p">])</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            np.unique considers all NaNs to be unique values</span>
<span class="sd">            These two lines find the indices of all NaNs in the unique value array </span>
<span class="sd">            and removes all but the first</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">nanvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">uvals</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Column </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> has </span><span class="si">{}</span><span class="s1"> unique values and </span><span class="si">{}</span><span class="s1"> NaNs&#39;</span>
                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col_ind</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nanvals</span><span class="p">)))</span>
            <span class="n">uvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">uvals</span><span class="p">,</span> <span class="n">nanvals</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check if more that one unique value</span>
<span class="sd">            Append column number to iSpec_var if true</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t\t</span><span class="s1">Column </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> had </span><span class="si">{}</span><span class="s1"> actually unique values&#39;</span>
                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col_ind</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uvals</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">uvals</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">iSpec_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iSpec_var</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">col_ind</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;UDVS matrix of shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">UDVS</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;Taking columns specified by iSpec_var: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">iSpec_var</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iSpec_var</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No variables were varied in UDVS table! Using UDVS step as &#39;</span>
                 <span class="s1">&#39;the only variable&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> \
                   <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">UDVS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>


        <span class="n">iSpec_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">iSpec_var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">ds_spec_val_mat</span> <span class="o">=</span> <span class="n">UDVS</span><span class="p">[:,</span> <span class="n">iSpec_var</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">iSpec_var</span><span class="p">,</span> <span class="n">ds_spec_val_mat</span>

    <span class="k">def</span> <span class="nf">__BEPSVals</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span> <span class="n">parm_dict</span><span class="p">,</span>
                   <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Spectroscopic Value array for a BEPS dataset</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        udvs_mat : hdf5 dataset reference to UDVS dataset</span>
<span class="sd">        spec_inds : numpy array containing Spectroscopic indices table </span>
<span class="sd">        bin_freqs : 1D numpy array of frequencies</span>
<span class="sd">        bin_wfm_type : numpy array containing the waveform type for each</span>
<span class="sd">            frequency index</span>
<span class="sd">        parm_dict : parameter dictinary for dataset</span>
<span class="sd">        udvs_labs : list of labels for the columns of the UDVS matrix</span>
<span class="sd">        udvs_units : list of units for the columns of the UDVS matrix</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_spec_val_mat : list holding final Spectroscopic Value table </span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the mode to determine if DC, AC, or something else</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_mode&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;DC modulation mode&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;current mode&#39;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">            First we call the FindSpecVals function to get the columns in UDVS </span>
<span class="sd">            of interest and return a first pass on the spectral value array </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;DC modulation mode / current mode&#39;</span><span class="p">)</span>
            <span class="n">iSpecVals</span><span class="p">,</span> <span class="n">inSpecVals</span> <span class="o">=</span> <span class="n">__FindSpecValIndices</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span>
                                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;Generated spec vals. Calling __BEPSDC&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">__BEPSDC</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">inSpecVals</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span>
                            <span class="n">parm_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;AC modulation mode with time reversal&#39;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">            First we call the FindSpecVals function to get the columns in UDVS</span>
<span class="sd">            of interest and return a first pass on the spectral value array </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;AC modulation&#39;</span><span class="p">)</span>
            <span class="n">iSpecVals</span><span class="p">,</span> <span class="n">inSpecVals</span> <span class="o">=</span> <span class="n">__FindSpecValIndices</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span>
                                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;Generated spec vals. Calling __BEPSAC&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">__BEPSAC</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">inSpecVals</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span>
                            <span class="n">parm_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">            First we call the FindSpecVals function to get the columns in UDVS</span>
<span class="sd">            of interest and return a first pass on the spectral value array </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;user defined voltage spectroscopy&#39;</span><span class="p">)</span>
            <span class="n">iSpecVals</span><span class="p">,</span> <span class="n">inSpecVals</span> <span class="o">=</span> <span class="n">__FindSpecValIndices</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span>
                                                         <span class="n">usr_defined</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="s1">&#39;Generated spec vals. Calling __BEPSgen&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">__BEPSgen</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">inSpecVals</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span>
                             <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">iSpecVals</span><span class="p">,</span> <span class="n">udvs_units</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__BEPSDC</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">inSpecVals</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span> <span class="n">parm_dict</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates Spectroscopic Values for BEPS data in DC modulation mode</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        udvs_mat : hdf5 dataset reference to UDVS dataset</span>
<span class="sd">        inSpecVals : list holding initial guess at spectral values </span>
<span class="sd">        bin_freqs : 1D numpy array of frequencies</span>
<span class="sd">        bin_wfm_type : numpy array containing the waveform type for each frequency index</span>
<span class="sd">        parm_dict : parameter dictinary for dataset</span>
<span class="sd">        verbose: bool, optional. Default = False</span>
<span class="sd">            Whether or not to print statements for debugging</span>
<span class="sd">                        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_spec_val_mat : list holding final Spectroscopic Value table </span>
<span class="sd">        SpecValsLabels : list holding labels of column names of ds_spec_val_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hascycles</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">hasFORCS</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># print(&#39;in shape:&#39;,np.shape(inSpecVals))</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All DC datasets will need Spectroscopic Value fields for Bin, DC, and Field</span>
<span class="sd">        </span>
<span class="sd">        Bin     - Bin number</span>
<span class="sd">        DC      - dc offset from UDVS</span>
<span class="sd">        Field   - 0 if in-field, 1 if out-of-field </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">ds_spec_val_labs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;DC_Offset&#39;</span><span class="p">]</span>
        <span class="n">ds_spec_val_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of and steps in the current dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numsteps</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the wave form for each step from udvs_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wave_form</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define list of attribute names needed from the group metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field_type</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_measure_in_field_loops&#39;</span><span class="p">]</span>
        <span class="n">numcycles</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_number_of_cycles&#39;</span><span class="p">]</span>
        <span class="n">numFORCs</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;FORC_num_of_FORC_cycles&#39;</span><span class="p">]</span>
        <span class="n">numcyclesteps</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_steps_per_full_cycle&#39;</span><span class="p">]</span>
        <span class="n">cycle_fraction</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_cycle_fraction&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">field_type</span> <span class="o">==</span> <span class="s1">&#39;in and out-of-field&#39;</span><span class="p">:</span>
            <span class="n">ds_spec_val_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Field&#39;</span><span class="p">)</span>
            <span class="n">ds_spec_val_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">nrow</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">frac</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;1/2&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;1/4&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;3/4&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">}</span>

        <span class="n">numcyclesteps</span> <span class="o">=</span> <span class="n">frac</span><span class="p">[</span><span class="n">cycle_fraction</span><span class="p">]</span> <span class="o">*</span> <span class="n">numcyclesteps</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the number of cycles and FORCs</span>
<span class="sd">        Add to Spectroscopic Values Labels as needed </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">numcycles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">hascycles</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nrow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ds_spec_val_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Cycle&#39;</span><span class="p">)</span>
            <span class="n">ds_spec_val_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numFORCs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">hasFORCS</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It&#39;s possible to have 1 cycle with multiple FORCs so force cycle tracking </span>
<span class="sd">        if FROCs exist</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">nrow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ds_spec_val_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;FORC&#39;</span><span class="p">)</span>
            <span class="n">ds_spec_val_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">numFORCsteps</span> <span class="o">=</span> <span class="n">numcycles</span> <span class="o">*</span> <span class="n">numcyclesteps</span> <span class="o">*</span> <span class="mi">2</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the field type</span>
<span class="sd">        For in-field and out-of-field we know all values of field ahead of time</span>
<span class="sd">        For in and out-of-field we must check at each step</span>
<span class="sd">        If something else is in field_type, we default to in and out-of-field and print message</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">field_type</span> <span class="o">==</span> <span class="s1">&#39;out-of-field&#39;</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">numsteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numsteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">numcyclesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numcyclesteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">swapfield</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">field_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;out-of-field&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">field_type</span> <span class="o">==</span> <span class="s1">&#39;in-field&#39;</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">numsteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numsteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">numcyclesteps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numcyclesteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">swapfield</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">field_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;in-field&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">field_type</span> <span class="o">==</span> <span class="s1">&#39;in and out-of-field&#39;</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">swapfield</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">field_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;out-of-field&#39;</span><span class="p">,</span> <span class="s1">&#39;in-field&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not a known field type&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_type</span><span class="p">))</span>
            <span class="n">field</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">swapfield</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize ds_spec_val_mat so that we can append to it in loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds_spec_val_mat_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main loop over all steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FORC</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;field_type: </span><span class="si">{}</span><span class="s1">, hascycles: </span><span class="si">{}</span><span class="s1">, hasFORCS: </span><span class="si">{}</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_type</span><span class="p">,</span> <span class="n">hascycles</span><span class="p">,</span> <span class="n">hasFORCS</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;Looping over </span><span class="si">{}</span><span class="s1"> steps&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">numsteps</span><span class="p">))</span>

        <span class="c1"># TODO: Make this horribly slow double for loop much faster!</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numsteps</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the cycle number if needed</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">hasFORCS</span><span class="p">:</span>
                <span class="n">FORC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">step</span> <span class="o">/</span> <span class="n">numFORCsteps</span><span class="p">)</span>
                <span class="n">stepinFORC</span> <span class="o">=</span> <span class="n">step</span> <span class="o">-</span> <span class="n">FORC</span> <span class="o">*</span> <span class="n">numFORCsteps</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepinFORC</span> <span class="o">/</span> <span class="n">numcyclesteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">hascycles</span><span class="p">:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">step</span> <span class="o">/</span> <span class="n">numcyclesteps</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Change field if needed</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">swapfield</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get bins for current step based on waveform</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">this_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bin_wfm_type</span> <span class="o">==</span> <span class="n">wave_form</span><span class="p">[</span><span class="n">step</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_wave</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Waveform type: </span><span class="si">{}</span><span class="s1"> not found in bin_wfm_type:&#39;</span>
                                 <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wave_form</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">bin_wfm_type</span><span class="p">))</span>
            <span class="c1"># print(&#39;\t&#39; * 6 + &#39;{}&#39;.format(inSpecVals[step]))</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="p">[</span><span class="n">inSpecVals</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">field_type</span> <span class="o">==</span> <span class="s1">&#39;in and out-of-field&#39;</span><span class="p">:</span>
                <span class="n">suffix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hascycles</span><span class="p">:</span>
                <span class="n">suffix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hasFORCS</span><span class="p">:</span>
                <span class="n">suffix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FORC</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="s1">&#39;Step: </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">: Suffix: </span><span class="si">{}</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">numsteps</span><span class="p">,</span> <span class="n">suffix</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="s1">&#39;this_wave of shape: </span><span class="si">{}</span><span class="s1">&#39;</span>
                                 <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Loop over bins</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># TODO: Vectorize this loop at a minimum</span>

            <span class="k">for</span> <span class="n">thisbin</span> <span class="ow">in</span> <span class="n">this_wave</span><span class="p">:</span>

                <span class="n">col_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_freqs</span><span class="p">[</span><span class="n">thisbin</span><span class="p">]]</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Add entries for field, cycle and/or FORC as needed</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="c1"># TODO: Why not add these later as columns instead of per row?</span>
                <span class="n">col_val</span> <span class="o">+=</span> <span class="n">suffix</span>

                <span class="n">ds_spec_val_mat_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_val</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="s1">&#39;At step </span><span class="si">{}</span><span class="s1"> ds_spec_val_mat_2: (</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">)&#39;</span>
                      <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_spec_val_mat_2</span><span class="p">),</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">ds_spec_val_mat_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

        <span class="n">ds_spec_val_mat_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ds_spec_val_mat_2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;Shape of spec val mats: </span><span class="si">{}</span><span class="s1">&#39;</span>
                  <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ds_spec_val_mat_2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ds_spec_val_mat_2</span><span class="p">,</span> <span class="n">ds_spec_val_labs</span><span class="p">,</span> <span class="n">ds_spec_val_units</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;Field&#39;</span><span class="p">,</span> <span class="n">field_names</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">__BEPSAC</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">inSpecVals</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span> <span class="n">parm_dict</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates Spectroscopic Values for BEPS data in AC modulation mode with time </span>
<span class="sd">                reversal</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        udvs_mat : hdf5 dataset reference to UDVS dataset</span>
<span class="sd">        inSpecVals : list holding initial guess at spectral values </span>
<span class="sd">        bin_freqs : 1D numpy array of frequencies</span>
<span class="sd">        bin_wfm_type : numpy array containing the waveform type for each frequency index</span>
<span class="sd">        parm_dict : parameter dictinary for dataset</span>
<span class="sd">        verbose: bool, optional. Default = False</span>
<span class="sd">            Whether or not to print statements for debugging</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_spec_val_mat : list holding final Spectroscopic Value table </span>
<span class="sd">        SpecValsLabels : list holding labels of column names of ds_spec_val_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hascycles</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">hasFORCS</span> <span class="o">=</span> <span class="kc">False</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All AC datasets will need Spectroscopic Value fields for Bin, AC, and Direction</span>
<span class="sd">        </span>
<span class="sd">        Bin     - Bin number</span>
<span class="sd">        AC      - AC amplitude from UDVS</span>
<span class="sd">        forrev   - 1 if forward, -1 if reverse </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">ds_spec_val_labs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;AC_Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Direction&#39;</span><span class="p">]</span>
        <span class="n">ds_spec_val_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hz&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of bins and steps in the current dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numsteps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the wave form for each step from udvs_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wave_form</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define list of attribute names needed from the group metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numcycles</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_number_of_cycles&#39;</span><span class="p">]</span>
        <span class="n">numFORCs</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;FORC_num_of_FORC_cycles&#39;</span><span class="p">]</span>
        <span class="n">numcyclesteps</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_steps_per_full_cycle&#39;</span><span class="p">]</span>
        <span class="n">cycle_fraction</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_cycle_fraction&#39;</span><span class="p">]</span>

        <span class="n">frac</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;1/2&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;1/4&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;3/4&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">}</span>

        <span class="n">numcyclesteps</span> <span class="o">=</span> <span class="n">frac</span><span class="p">[</span><span class="n">cycle_fraction</span><span class="p">]</span> <span class="o">*</span> <span class="n">numcyclesteps</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the number of cycles and FORCs</span>
<span class="sd">        Add to Spectroscopic Values Labels as needed </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">numcycles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">hascycles</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nrow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ds_spec_val_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Cycle&#39;</span><span class="p">)</span>
            <span class="n">ds_spec_val_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numFORCs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">hasFORCS</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nrow</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ds_spec_val_labs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;FORC&#39;</span><span class="p">)</span>
            <span class="n">ds_spec_val_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">numFORCsteps</span> <span class="o">=</span> <span class="n">numcycles</span> <span class="o">*</span> <span class="n">numcyclesteps</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize ds_spec_val_mat so that we can append to it in loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds_spec_val_mat_2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main loop over all steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">FORC</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">cycle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Generating spectroscopic values for AC spectroscopy. This can &#39;</span>
             <span class="s1">&#39;take a while. Please be patient&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numsteps</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="kc">False</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;Working on step: </span><span class="si">{}</span><span class="s1"> of </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">,</span>
                                                                    <span class="n">numsteps</span><span class="p">))</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate the cycle number if needed</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">hasFORCS</span><span class="p">:</span>
                <span class="n">FORC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">step</span> <span class="o">/</span> <span class="n">numFORCsteps</span><span class="p">)</span>
                <span class="n">stepinFORC</span> <span class="o">=</span> <span class="n">step</span> <span class="o">-</span> <span class="n">FORC</span> <span class="o">*</span> <span class="n">numFORCsteps</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">stepinFORC</span> <span class="o">/</span> <span class="n">numcyclesteps</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">hascycles</span><span class="p">:</span>
                <span class="n">cycle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">step</span> <span class="o">/</span> <span class="n">numcyclesteps</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Check the wave_mod</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">wmod</span> <span class="o">=</span> <span class="n">inSpecVals</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">forrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">wmod</span><span class="p">)</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get bins for current step based on waveform</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">this_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bin_wfm_type</span> <span class="o">==</span> <span class="n">wave_form</span><span class="p">[</span><span class="n">step</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">suffix</span> <span class="o">=</span> <span class="p">[</span><span class="n">inSpecVals</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">forrev</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">hascycles</span><span class="p">:</span>
                <span class="n">suffix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hasFORCS</span><span class="p">:</span>
                <span class="n">suffix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FORC</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="s1">&#39;Step: </span><span class="si">{}</span><span class="s1">: Suffix: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">suffix</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="s1">&#39;this_wave of shape: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">this_wave</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Loop over bins</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># TODO: Consider vectorizing here</span>
            <span class="k">for</span> <span class="n">thisbin</span> <span class="ow">in</span> <span class="n">this_wave</span><span class="p">:</span>

                <span class="n">col_val</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_freqs</span><span class="p">[</span><span class="n">thisbin</span><span class="p">]]</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Add entries to cycle and/or FORC as needed</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">col_val</span> <span class="o">+=</span> <span class="n">suffix</span>

                <span class="n">ds_spec_val_mat_2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_val</span><span class="p">)</span>

        <span class="n">ds_spec_val_mat_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ds_spec_val_mat_2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="s1">&#39;Shape of spec val mats: </span><span class="si">{}</span><span class="s1">&#39;</span>
                             <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ds_spec_val_mat_2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">ds_spec_val_mat_2</span><span class="p">,</span> <span class="n">ds_spec_val_labs</span><span class="p">,</span> <span class="n">ds_spec_val_units</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;Direction&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;reverse&#39;</span><span class="p">,</span> <span class="s1">&#39;forward&#39;</span><span class="p">]]]</span>

    <span class="k">def</span> <span class="nf">__BEPSgen</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">inSpecVals</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span> <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">iSpecVals</span><span class="p">,</span> <span class="n">udvs_units</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates Spectroscopic Values for BEPS data in generic mode</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        udvs_mat : hdf5 dataset reference to UDVS dataset</span>
<span class="sd">        inSpecVals : list holding initial guess at spectral values </span>
<span class="sd">        bin_freqs : 1D numpy array of frequencies</span>
<span class="sd">        bin_wfm_type : numpy array containing the waveform type for each frequency index</span>
<span class="sd">        udvs_labs : list of labels for the columns of the UDVS matrix</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_spec_val_mat -- list holding final Spectroscopic Value table </span>
<span class="sd">        SpecValsLabels -- list holding labels of column names of ds_spec_val_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of bins and steps in the current dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">numsteps</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the wave form for each step from udvs_mat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wave_form</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All datasets will need Spectroscopic Value fields for Bin,</span>
<span class="sd">        everything else must be defined</span>
<span class="sd">        </span>
<span class="sd">        Bin     - Bin number</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds_spec_val_labs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency&#39;</span><span class="p">]</span>
        <span class="n">ds_spec_val_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hz&#39;</span><span class="p">]</span>

        <span class="n">ds_spec_val_labs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">udvs_labs</span><span class="p">[(</span><span class="n">iSpecVals</span><span class="p">[:])])</span>
        <span class="n">ds_spec_val_units</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">udvs_units</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iSpecVals</span><span class="p">])</span>
        <span class="n">nrow</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds_spec_val_labs</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize ds_spec_val_mat so that we can append to it in loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds_spec_val_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nrow</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main loop over all steps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numsteps</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Get the wave form for each step from udvs_mat</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">this_wave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bin_wfm_type</span> <span class="o">==</span> <span class="n">wave_form</span><span class="p">[</span><span class="n">step</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">thisbin</span> <span class="ow">in</span> <span class="n">this_wave</span><span class="p">:</span>
                <span class="n">colVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">bin_freqs</span><span class="p">[</span><span class="n">thisbin</span><span class="p">]]])</span>
                <span class="n">colVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">colVal</span><span class="p">,</span> <span class="p">[[</span><span class="n">row</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">inSpecVals</span><span class="p">[</span><span class="n">step</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">ds_spec_val_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds_spec_val_mat</span><span class="p">,</span> <span class="n">colVal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ds_spec_val_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">ds_spec_val_labs</span><span class="p">,</span> <span class="n">ds_spec_val_units</span><span class="p">,</span> <span class="p">[]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">********************************************************************************************</span>
<span class="sd">    END OF INTERNAL FUNCTION LIST</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;data_type&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;BELineData&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Working on BE Line data&#39;</span><span class="p">)</span>
        <span class="n">ds_spec_val_mat</span> <span class="o">=</span> <span class="n">bin_freqs</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ds_spec_inds_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ds_spec_val_mat</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ds_spec_val_labs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency&#39;</span><span class="p">]</span>
        <span class="n">ds_spec_val_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hz&#39;</span><span class="p">]</span>
        <span class="n">spec_vals_labs_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ds_spec_inds_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ds_spec_val_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;BEPSData&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Working on BEPS data. Calling __BEPSVals&#39;</span><span class="p">)</span>
        <span class="c1"># Call BEPSVals to finish the refining of the Spectroscopic Value array</span>
        <span class="n">ret_vals</span> <span class="o">=</span> <span class="n">__BEPSVals</span><span class="p">(</span><span class="n">udvs_mat</span><span class="p">,</span> <span class="n">spec_inds</span><span class="p">,</span> <span class="n">bin_freqs</span><span class="p">,</span> <span class="n">bin_wfm_type</span><span class="p">,</span>
                              <span class="n">parm_dict</span><span class="p">,</span> <span class="n">udvs_labs</span><span class="p">,</span> <span class="n">udvs_units</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Generated values from BEPSVals internal function&#39;</span><span class="p">)</span>
        <span class="n">ds_spec_val_mat</span><span class="p">,</span> <span class="n">ds_spec_val_labs</span><span class="p">,</span> <span class="n">ds_spec_val_units</span><span class="p">,</span> <span class="n">spec_vals_labs_names</span> <span class="o">=</span> <span class="n">ret_vals</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">parm_dict</span><span class="p">[</span><span class="s1">&#39;VS_mode&#39;</span><span class="p">]</span>
        <span class="c1"># TODO: This is a very slow step - vectorize?</span>
        <span class="k">if</span> <span class="n">ds_spec_val_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">500E+3</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Please be patient while spectroscopic indices are being &#39;</span>
                 <span class="s1">&#39;generated&#39;</span><span class="p">)</span>
        <span class="n">ds_spec_inds_mat</span> <span class="o">=</span> <span class="n">create_spec_inds_from_vals</span><span class="p">(</span><span class="n">ds_spec_val_mat</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Returned from create_spec_inds_from_vals&#39;</span><span class="p">)</span>

        <span class="c1"># Make sure that the frequencies reset properly for user defined case</span>
        <span class="n">spec_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;load user defined VS Wave from file&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">Making sure that the frequencies reset properly &#39;</span>
                      <span class="s1">&#39;for user defined voltage spectroscopy case&#39;</span><span class="p">)</span>
            <span class="n">wave_form</span> <span class="o">=</span> <span class="n">udvs_mat</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="n">wave_form</span><span class="p">:</span>
                <span class="n">wave_freqs</span> <span class="o">=</span> <span class="n">bin_freqs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">bin_wfm_type</span> <span class="o">==</span> <span class="n">wave</span><span class="p">)]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
                <span class="n">num_bins</span> <span class="o">=</span> <span class="n">wave_freqs</span><span class="o">.</span><span class="n">size</span>
                <span class="n">ds_spec_inds_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">spec_start</span><span class="p">:</span><span class="n">spec_start</span> <span class="o">+</span> <span class="n">num_bins</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
                <span class="n">spec_start</span> <span class="o">+=</span> <span class="n">num_bins</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Unknown format! Cannot generate Spectroscopic Values!&#39;</span><span class="p">)</span>
        <span class="n">ds_spec_val_mat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ds_spec_inds_mat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ds_spec_val_labs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ds_spec_val_units</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spec_vals_labs_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="n">ds_spec_val_mat</span><span class="p">,</span> <span class="n">ds_spec_inds_mat</span><span class="p">,</span> <span class="n">ds_spec_val_labs</span><span class="p">,</span> <span class="n">ds_spec_val_units</span><span class="p">,</span> <span class="n">spec_vals_labs_names</span></div>



<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">BEHistogram Class and Functions</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="BEHistogram">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.BEHistogram.html#BGlib.be.translators.df_utils.be_utils.BEHistogram">[docs]</a>
<span class="k">class</span> <span class="nc">BEHistogram</span><span class="p">:</span>
    <span class="c1"># TODO: Make into Process class</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class just functions as a container so we can have shared objects</span>
<span class="sd">    Chris Smith -- csmith55@utk.edu</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_response</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_response</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_spectral_steps</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_bins</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_freqs</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_y_bins</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="BEHistogram.addBEHist">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.BEHistogram.html#BGlib.be.translators.df_utils.be_utils.BEHistogram.addBEHist">[docs]</a>
    <span class="k">def</span> <span class="nf">addBEHist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">,</span> <span class="n">max_mem_mb</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">show_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function adds Histgrams from the Main Data to the Plot Groups for</span>
<span class="sd">        an existing hdf5 BEPS datafile.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_path : string</span>
<span class="sd">            the path to the hdf5 datafile</span>
<span class="sd">        max_mem_mb : unsigned integer</span>
<span class="sd">            the maximum amount of memory to use during the binning</span>
<span class="sd">        show_plot : Boolean</span>
<span class="sd">            Should plot of the histograms be drawn after they are</span>
<span class="sd">            created</span>
<span class="sd">        save_plot : Boolean</span>
<span class="sd">            Should plots of the histograms be saved</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hdf</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r+&#39;</span><span class="p">)</span>
        <span class="n">h5_file</span> <span class="o">=</span> <span class="n">hdf</span><span class="o">.</span><span class="n">file</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Adding Histograms to file </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5_file</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Path to HDF5 file is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hdf</span><span class="o">.</span><span class="n">path</span><span class="p">))</span>

        <span class="n">max_mem</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_mem_mb</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">get_available_memory</span><span class="p">())</span>

        <span class="n">h5_main</span> <span class="o">=</span> <span class="n">find_dataset</span><span class="p">(</span><span class="n">h5_file</span><span class="p">,</span> <span class="s1">&#39;Raw_Data&#39;</span><span class="p">)</span>
        <span class="n">h5_udvs</span> <span class="o">=</span> <span class="n">find_dataset</span><span class="p">(</span><span class="n">h5_file</span><span class="p">,</span> <span class="s1">&#39;UDVS&#39;</span><span class="p">)</span>

        <span class="n">m_groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">h5_main</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Measurement groups found.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m_groups</span><span class="p">)))</span>

        <span class="k">for</span> <span class="n">im</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">m_groups</span><span class="p">):</span>

            <span class="n">p_groups</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">mspecs</span> <span class="o">=</span> <span class="n">find_dataset</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s1">&#39;Mean_Spectrogram&#39;</span><span class="p">)</span>
            <span class="n">p_groups</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mspec</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">mspec</span> <span class="ow">in</span> <span class="n">mspecs</span><span class="p">])</span>

            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Plot groups in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_groups</span><span class="p">),</span> <span class="n">group</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">ip</span><span class="p">,</span> <span class="n">p_group</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_groups</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">max_resp</span> <span class="o">=</span> <span class="n">find_dataset</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s1">&#39;Max_Response&#39;</span><span class="p">)</span>
                    <span class="n">min_resp</span> <span class="o">=</span> <span class="n">find_dataset</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="s1">&#39;Min_Response&#39;</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Maximum and Minimum Response vectors not found for </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_group</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">max_resp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">min_resp</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Creating BEHistogram for Plot Group </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p_group</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">udvs_lab</span> <span class="o">=</span> <span class="n">p_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;Name&#39;</span><span class="p">]</span>
                <span class="n">udvs_col</span> <span class="o">=</span> <span class="n">h5_udvs</span><span class="p">[</span><span class="n">im</span><span class="p">][</span><span class="n">h5_udvs</span><span class="p">[</span><span class="n">im</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">udvs_lab</span><span class="p">]]</span>
                <span class="n">actual_udvs_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">udvs_col</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Add the BEHistogram for the current plot group</span>
<span class="sd">                &quot;&quot;&quot;</span>

                <span class="n">plot_grp</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">p_group</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">write_simple_attrs</span><span class="p">(</span><span class="n">plot_grp</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;Name&#39;</span><span class="p">:</span> <span class="n">udvs_lab</span><span class="p">})</span>

                <span class="n">hist</span> <span class="o">=</span> <span class="n">BEHistogram</span><span class="p">()</span>
                <span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_labels</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">hist_indices_labels</span> <span class="o">=</span> \
                    <span class="n">hist</span><span class="o">.</span><span class="n">buildPlotGroupHist</span><span class="p">(</span><span class="n">h5_main</span><span class="p">[</span><span class="n">im</span><span class="p">],</span>
                                            <span class="n">actual_udvs_steps</span><span class="p">,</span>
                                            <span class="n">max_response</span><span class="o">=</span><span class="n">max_resp</span><span class="p">,</span>
                                            <span class="n">min_response</span><span class="o">=</span><span class="n">min_resp</span><span class="p">,</span>
                                            <span class="n">max_mem_mb</span><span class="o">=</span><span class="n">max_mem</span><span class="p">)</span>

                <span class="n">ds_hist</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Histograms&#39;</span><span class="p">,</span>
                                                  <span class="n">data</span><span class="o">=</span><span class="n">hist_mat</span><span class="p">,</span>
                                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">write_simple_attrs</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">hist_labels</span><span class="p">})</span>

                <span class="n">ds_hist_indices</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Histograms_Indices&#39;</span><span class="p">,</span>
                                                          <span class="n">data</span><span class="o">=</span><span class="n">hist_indices</span><span class="p">,</span>
                                                          <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">write_simple_attrs</span><span class="p">(</span><span class="n">ds_hist_indices</span><span class="p">,</span>
                                   <span class="p">{</span><span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">hist_indices_labels</span><span class="p">})</span>

                <span class="n">ds_hist_labels</span> <span class="o">=</span> <span class="n">plot_grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Histograms_Labels&#39;</span><span class="p">,</span>
                                                         <span class="n">data</span><span class="o">=</span><span class="n">hist_labels</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">show_plot</span> <span class="ow">or</span> <span class="n">save_plot</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
                        <span class="n">basename</span><span class="p">,</span> <span class="n">junk</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">h5_path</span><span class="p">)</span>
                        <span class="n">plotfile</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_MG</span><span class="si">{}</span><span class="s1">_PG</span><span class="si">{}</span><span class="s1">_Histograms.png&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">basename</span><span class="p">,</span> <span class="n">im</span><span class="p">,</span> <span class="n">ip</span><span class="p">)</span>
                    <span class="n">plot_histograms</span><span class="p">(</span><span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">p_group</span><span class="p">,</span> <span class="n">plotfile</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">show_plot</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">hdf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="BEHistogram.buildBEHist">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.BEHistogram.html#BGlib.be.translators.df_utils.be_utils.BEHistogram.buildBEHist">[docs]</a>
    <span class="k">def</span> <span class="nf">buildBEHist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_main</span><span class="p">,</span> <span class="n">max_response</span><span class="o">=</span><span class="p">[],</span> <span class="n">min_response</span><span class="o">=</span><span class="p">[],</span> <span class="n">max_mem_mb</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">max_bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates Histograms from dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_main : hdf5.Dataset</span>
<span class="sd">        max_response : list</span>
<span class="sd">        min_response : list</span>
<span class="sd">        max_mem_mb : int</span>
<span class="sd">        max_bins : int</span>
<span class="sd">        debug : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free_mem</span> <span class="o">=</span> <span class="n">get_available_memory</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have </span><span class="si">{}</span><span class="s1"> bytes of memory available&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">free_mem</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_mem_mb</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">free_mem</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that max_response and min_response have been defined.</span>
<span class="sd">        Call __getminmaxresponse__ is not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_response</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">min_response</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">max_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h5_main</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">min_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h5_main</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">max_response</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">max_response</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">min_response</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">min_response</span><span class="p">)])</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over all datasets</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">active_udvs_steps</span> <span class="o">=</span> <span class="n">getActiveUDVSsteps</span><span class="p">(</span><span class="n">h5_main</span><span class="p">)</span>  <span class="c1"># technically needs to be done only once</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_udvs_steps</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load auxilary datasets and extract needed parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spec_ind_mat</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Spectroscopic_Indices&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_spectral_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">spec_ind_mat</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up frequency axis of histogram, same for all histograms in a single dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freqs_mat</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Bin_Frequencies&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spec_ind_mat</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freqs_mat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">freqs_mat</span><span class="p">))</span>
        <span class="c1"># print(&#39;There are {} total frequencies in this dataset&#39;.format(self.N_bins))</span>
        <span class="k">del</span> <span class="n">freqs_mat</span><span class="p">,</span> <span class="n">spec_ind_mat</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">h5_main</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># print(&#39;There are {} pixels in this dataset&#39;.format(self.N_pixels))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_y_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">max_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_spectral_steps</span><span class="p">)))))</span>
        <span class="c1">#         self.N_y_bins = np.min( (max_bins, np.rint(2*(self.N_pixels*self.N_spectral_steps)**(1.0/3.0))))</span>
        <span class="c1"># print(&#39;{} bins will be used&#39;.format(self.N_y_bins))</span>

        <span class="n">ds_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__datasetHist</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">active_udvs_steps</span><span class="p">,</span> <span class="n">x_hist</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ds_hist</span></div>


<div class="viewcode-block" id="BEHistogram.buildPlotGroupHist">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.BEHistogram.html#BGlib.be.translators.df_utils.be_utils.BEHistogram.buildPlotGroupHist">[docs]</a>
    <span class="k">def</span> <span class="nf">buildPlotGroupHist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_main</span><span class="p">,</span> <span class="n">active_spec_steps</span><span class="p">,</span> <span class="n">max_response</span><span class="o">=</span><span class="p">[],</span>
                           <span class="n">min_response</span><span class="o">=</span><span class="p">[],</span> <span class="n">max_mem_mb</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">max_bins</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                           <span class="n">std_mult</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates Histograms for a given plot group</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_main : HDF5 Dataset object</span>
<span class="sd">            Dataset to be historammed</span>
<span class="sd">        active_spec_steps : numpy array</span>
<span class="sd">            active spectral steps in the current plot group</span>
<span class="sd">        max_response : numpy array</span>
<span class="sd">            maximum amplitude at each pixel</span>
<span class="sd">        min_response : numpy array</span>
<span class="sd">            minimum amplitude at each pixel</span>
<span class="sd">        max_mem_mb : Unsigned integer</span>
<span class="sd">            maximum number of Mb allowed for use.  Used to calculate the</span>
<span class="sd">            number of pixels to load in a chunk</span>
<span class="sd">        max_bins : integer</span>
<span class="sd">            maximum number of spectroscopic bins</span>
<span class="sd">        std_mult : integer</span>
<span class="sd">            number of standard deviations from the mean of</span>
<span class="sd">            max_response and min_response to include in</span>
<span class="sd">            binning</span>
<span class="sd">        debug : boolean</span>
<span class="sd">            Turns on debug printing statements if true.  Default False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hist_mat : 2d numpy array</span>
<span class="sd">            4 histograms as 1d arrays</span>
<span class="sd">        hist_labels : list of strings</span>
<span class="sd">            names for the 4 rows in hist_mat</span>
<span class="sd">        hist_indices : 2d numpy array</span>
<span class="sd">            the frequency and spectroscopic bins of each column in hist_mat</span>
<span class="sd">        hist_index_labels : list of strings</span>
<span class="sd">            labels for the hist_indices array</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">free_mem</span> <span class="o">=</span> <span class="n">get_available_memory</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have </span><span class="si">{}</span><span class="s1"> bytes of memory available&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">free_mem</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_mem_mb</span><span class="p">,</span> <span class="mf">0.75</span> <span class="o">*</span> <span class="n">free_mem</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that max_response and min_response have been defined.</span>
<span class="sd">        Call __getminmaxresponse__ is not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_response</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">min_response</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">max_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h5_main</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">min_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">h5_main</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">max_response</span><span class="p">)</span> <span class="o">+</span> <span class="n">std_mult</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">max_response</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">min_response</span><span class="p">)</span> <span class="o">-</span> <span class="n">std_mult</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">min_response</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">max_response</span><span class="p">,</span> <span class="n">min_response</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load auxilary datasets and extract needed parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">step_ind_mat</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;UDVS_Indices&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="n">spec_ind_mat</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Spectroscopic_Indices&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_spectral_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">step_ind_mat</span><span class="p">)</span>

        <span class="n">active_udvs_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">step_ind_mat</span><span class="p">[</span><span class="n">active_spec_steps</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_udvs_steps</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up frequency axis of histogram, same for all histograms in a single dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freqs_mat</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Bin_Frequencies&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spec_ind_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step_ind_mat</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">freqs_mat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">freqs_mat</span><span class="p">))</span>

        <span class="k">del</span> <span class="n">freqs_mat</span><span class="p">,</span> <span class="n">step_ind_mat</span><span class="p">,</span> <span class="n">spec_ind_mat</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">h5_main</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">#         self.N_y_bins = np.int(np.min( (max_bins, np.rint(np.sqrt(self.N_pixels*self.N_spectral_steps)))))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N_y_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">max_bins</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_spectral_steps</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)))))</span>

        <span class="n">ds_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__datasetHist</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">active_udvs_steps</span><span class="p">,</span> <span class="n">x_hist</span><span class="p">,</span> <span class="n">debug</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ds_hist max&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">),</span> <span class="s1">&#39;ds_hist min&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">))</span>

        <span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_labels</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">hist_index_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__reshapeHist</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_labels</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">hist_index_labels</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">__reshapeHist</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reshape the histogram matrix into table, and build the associated index table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ds_hist : numpy array</span>
<span class="sd">            the 4 histogram matrices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hist_mat : 2d numpy array</span>
<span class="sd">            the 4 histograms as 1d arrays</span>
<span class="sd">        hist_labels : list of strings</span>
<span class="sd">            names for the 4 rows in hist_mat</span>
<span class="sd">        hist_indices : 2d numpy array</span>
<span class="sd">            the frequency and spectroscopic bins of each column in hist_mat</span>
<span class="sd">        hist_index_labels : list of strings</span>
<span class="sd">            labels for the hist_indices array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hist_shape</span> <span class="o">=</span> <span class="n">ds_hist</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">hist_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">,</span> <span class="p">(</span><span class="n">hist_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hist_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hist_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

        <span class="n">hist_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Phase&#39;</span><span class="p">,</span> <span class="s1">&#39;Real Part&#39;</span><span class="p">,</span> <span class="s1">&#39;Imaginary Part&#39;</span><span class="p">]</span>

        <span class="n">hist_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">hist_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">hist_index_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency Bin&#39;</span><span class="p">,</span> <span class="s1">&#39;Spectroscopic Bin&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">isbin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hist_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">ifbin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hist_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">ihbin</span> <span class="o">=</span> <span class="n">ifbin</span> <span class="o">+</span> <span class="n">isbin</span> <span class="o">*</span> <span class="n">hist_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">hist_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ihbin</span><span class="p">]</span> <span class="o">=</span> <span class="n">ifbin</span>
                <span class="n">hist_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">ihbin</span><span class="p">]</span> <span class="o">=</span> <span class="n">isbin</span>

        <span class="k">return</span> <span class="n">hist_mat</span><span class="p">,</span> <span class="n">hist_labels</span><span class="p">,</span> <span class="n">hist_indices</span><span class="p">,</span> <span class="n">hist_index_labels</span>

    <span class="k">def</span> <span class="nf">__datasetHist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_main</span><span class="p">,</span> <span class="n">active_udvs_steps</span><span class="p">,</span> <span class="n">x_hist</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the histogram for a single dataset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_main : HDF5 Dataset</span>
<span class="sd">            Main_Dataset to be histogramed</span>
<span class="sd">        active_udvs_steps : numpy array</span>
<span class="sd">            the active udvs steps in the current plot group</span>
<span class="sd">        x_hist : 1d numpy array</span>
<span class="sd">            the spectroscopic indices matrix, used to find the</span>
<span class="sd">            spectroscopic indices of each udvs step</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ds_hist : numpy array</span>
<span class="sd">            the 4 histogram matrices</span>

<span class="sd">        &quot;&quot;&quot;</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate maximum number of pixels to read at once</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_pixels</span> <span class="o">=</span> <span class="n">maxReadPixels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span><span class="p">,</span>
                                   <span class="n">bytes_per_bin</span><span class="o">=</span><span class="n">h5_main</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_y_bins</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_freqs</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the pixels into chunks that will fit in memory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pix_chunks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span><span class="p">,</span> <span class="n">max_pixels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the histograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ds_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_freqs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_y_bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        loop over pixels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ichunk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pix_chunks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pixel chunk&#39;</span><span class="p">,</span> <span class="n">ichunk</span><span class="p">)</span>

            <span class="n">chunk</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">pix_chunks</span><span class="p">[</span><span class="n">ichunk</span><span class="p">],</span> <span class="n">pix_chunks</span><span class="p">[</span><span class="n">ichunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over active UDVS steps</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">iudvs</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span><span class="p">):</span>
                <span class="n">selected</span> <span class="o">=</span> <span class="p">(</span><span class="n">iudvs</span> <span class="o">+</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span><span class="p">)</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">selected</span><span class="p">:</span>
                    <span class="n">per_done</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
                        <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">iudvs</span> <span class="o">+</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_udvs_steps</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_pixels</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Binning BEHistogram...</span><span class="si">{}</span><span class="s1">% --pixels </span><span class="si">{}</span><span class="s1">-</span><span class="si">{}</span><span class="s1">, step # </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">per_done</span><span class="p">,</span> <span class="n">chunk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                                                       <span class="n">chunk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">iudvs</span><span class="p">))</span>
                <span class="n">udvs_step</span> <span class="o">=</span> <span class="n">active_udvs_steps</span><span class="p">[</span><span class="n">iudvs</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;udvs step&#39;</span><span class="p">,</span> <span class="n">udvs_step</span><span class="p">)</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the correct Spectroscopic bins for the current UDVS step</span>
<span class="sd">        Read desired pixel chunk from these bins for Main_Data into data_mat</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">udvs_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x_hist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">udvs_step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x_hist</span><span class="p">))</span>
                <span class="n">data_mat</span> <span class="o">=</span> <span class="n">h5_main</span><span class="p">[</span><span class="n">pix_chunks</span><span class="p">[</span><span class="n">ichunk</span><span class="p">]:</span><span class="n">pix_chunks</span><span class="p">[</span><span class="n">ichunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">udvs_bins</span><span class="p">]</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the frequecies that correspond to the current UDVS bins from the total x_hist</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">this_x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">udvs_bins</span><span class="p">)</span>
                <span class="n">this_x_hist</span> <span class="o">=</span> <span class="n">this_x_hist</span> <span class="o">-</span> <span class="n">this_x_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">this_x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">this_x_hist</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">pix_chunks</span><span class="p">[</span><span class="n">ichunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pix_chunks</span><span class="p">[</span><span class="n">ichunk</span><span class="p">])))</span>
                <span class="n">this_x_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">this_x_hist</span><span class="p">)</span>

                <span class="n">N_x_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">this_x_hist</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N_x_bins&#39;</span><span class="p">,</span> <span class="n">N_x_bins</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">this_x_hist</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">this_x_hist</span><span class="p">))</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create weighting vector.  If setting all to one value, can be a scalar.</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">weighting_vec</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data_mat</span><span class="p">))</span>

<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up the list of functions to call and their corresponding maxima and minima</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">func_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">]</span>
                <span class="n">max_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_response</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_response</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_response</span><span class="p">]</span>
                <span class="n">min_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">min_response</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_response</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_response</span><span class="p">]</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Histograms and store in correct place in ds_hist</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">ifunc</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">func_list</span><span class="p">):</span>
                    <span class="n">chunk_hist</span> <span class="o">=</span> <span class="n">build_histogram</span><span class="p">(</span><span class="n">this_x_hist</span><span class="p">,</span>
                                                 <span class="n">data_mat</span><span class="p">,</span>
                                                 <span class="n">N_x_bins</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">N_y_bins</span><span class="p">,</span>
                                                 <span class="n">weighting_vec</span><span class="p">,</span>
                                                 <span class="n">min_list</span><span class="p">[</span><span class="n">ifunc</span><span class="p">],</span>
                                                 <span class="n">max_list</span><span class="p">[</span><span class="n">ifunc</span><span class="p">],</span>
                                                 <span class="n">func</span><span class="p">,</span>
                                                 <span class="n">debug</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;chunkhist-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">chunk_hist</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">chunk_hist</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

                    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ifreq</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">udvs_bins</span><span class="p">):</span>
                        <span class="n">ids_freq</span> <span class="o">=</span> <span class="n">this_x_hist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ifreq</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">ids_freq</span><span class="p">)</span>
                        <span class="n">ds_hist</span><span class="p">[</span><span class="n">ifunc</span><span class="p">,</span> <span class="n">ids_freq</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ds_hist</span><span class="p">[</span><span class="n">ifunc</span><span class="p">,</span> <span class="n">ids_freq</span><span class="p">,</span> <span class="p">:],</span> <span class="n">chunk_hist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">return</span> <span class="n">ds_hist</span></div>



<div class="viewcode-block" id="maxReadPixels">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.maxReadPixels.html#BGlib.be.translators.df_utils.be_utils.maxReadPixels">[docs]</a>
<span class="k">def</span> <span class="nf">maxReadPixels</span><span class="p">(</span><span class="n">max_memory</span><span class="p">,</span> <span class="n">tot_pix</span><span class="p">,</span> <span class="n">bins_per_step</span><span class="p">,</span> <span class="n">bytes_per_bin</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the maximum number of pixels that can be loaded into the</span>
<span class="sd">    specified memory size. This is particularly useful when applying a</span>
<span class="sd">    (typically parallel) operation / processing on each pixel.</span>
<span class="sd">    Example - Fitting response to a model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------------</span>
<span class="sd">    max_memory : unsigned int</span>
<span class="sd">        Maximum memory (in bytes) that can be used.</span>
<span class="sd">        For example 4 GB would be = 4*((2**10)**3) bytes</span>
<span class="sd">    tot_pix : unsigned int</span>
<span class="sd">        Total number of pixels in dataset</span>
<span class="sd">    bins_per_step : unsigned int</span>
<span class="sd">        Number of bins that will be read (can be portion of each pixel)</span>
<span class="sd">    bytes_per_bin : (Optional) unsigned int</span>
<span class="sd">        size of each bin - set to 4 bytes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    max_pix : unsigned int</span>
<span class="sd">        Maximum number of pixels that will be loaded</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># alternatively try .nbytes</span>
    <span class="n">bytes_per_step</span> <span class="o">=</span> <span class="n">bins_per_step</span> <span class="o">*</span> <span class="n">bytes_per_bin</span>
    <span class="n">max_pix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">max_memory</span> <span class="o">/</span> <span class="n">bytes_per_step</span><span class="p">)</span>
    <span class="c1"># print(&#39;Allowed to read {} of {} pixels&#39;.format(max_pix,tot_pix))</span>
    <span class="n">max_pix</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">tot_pix</span><span class="p">,</span> <span class="n">max_pix</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">uint</span><span class="p">(</span><span class="n">max_pix</span><span class="p">)</span></div>



<div class="viewcode-block" id="getActiveUDVSsteps">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getActiveUDVSsteps.html#BGlib.be.translators.df_utils.be_utils.getActiveUDVSsteps">[docs]</a>
<span class="k">def</span> <span class="nf">getActiveUDVSsteps</span><span class="p">(</span><span class="n">h5_raw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all the active UDVS steps in the data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_raw : HDF5 dataset reference</span>
<span class="sd">        Reference to the raw data</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    steps : 1D numpy array</span>
<span class="sd">        Active UDVS steps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">udvs_step_vec</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_raw</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;UDVS_Indices&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">udvs_step_vec</span><span class="p">)</span></div>



<div class="viewcode-block" id="getSliceForExcWfm">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getSliceForExcWfm.html#BGlib.be.translators.df_utils.be_utils.getSliceForExcWfm">[docs]</a>
<span class="k">def</span> <span class="nf">getSliceForExcWfm</span><span class="p">(</span><span class="n">h5_bin_wfm</span><span class="p">,</span> <span class="n">excit_wfm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices that correspond to the given excitation waveform</span>
<span class="sd">    that can be used to slice the bin datasets</span>
<span class="sd">    * Developer note - Replace the first parameter with the Raw_Data dataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    h5_bin_wfm : Reference to HDF5 dataset</span>
<span class="sd">        Bin Waveform Indices</span>
<span class="sd">    excit_wfm : integer</span>
<span class="sd">        excitation waveform / wave type</span>

<span class="sd">    Returns</span>
<span class="sd">    --------------</span>
<span class="sd">    slc : slice object</span>
<span class="sd">        Slice with the start and end indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h5_bin_wfm</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">excit_wfm</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Need to add one additional index otherwise, the last index will be lost</span></div>



<div class="viewcode-block" id="getDataIndicesForUDVSstep">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getDataIndicesForUDVSstep.html#BGlib.be.translators.df_utils.be_utils.getDataIndicesForUDVSstep">[docs]</a>
<span class="k">def</span> <span class="nf">getDataIndicesForUDVSstep</span><span class="p">(</span><span class="n">h5_udvs_inds</span><span class="p">,</span> <span class="n">udvs_step_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the spectroscopic indices that correspond to the given udvs_step_index</span>
<span class="sd">    that can be used to slice the main data matrix.</span>
<span class="sd">    * Developer note - Replace the first parameter with the Raw_Data dataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------------</span>
<span class="sd">    h5_udvs_inds : Reference to HDF5 dataset</span>
<span class="sd">        UDVS_Indices dataset</span>
<span class="sd">    udvs_step_index : usigned int</span>
<span class="sd">        UDVS step index (base 0)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------------</span>
<span class="sd">    ans : 1D numpy array</span>
<span class="sd">        Spectroscopic indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spec_ind_udvs_step_col</span> <span class="o">=</span> <span class="n">h5_udvs_inds</span><span class="p">[</span><span class="n">h5_udvs_inds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;UDVS_Step&#39;</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spec_ind_udvs_step_col</span> <span class="o">==</span> <span class="n">udvs_step_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="getSpecSliceForUDVSstep">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getSpecSliceForUDVSstep.html#BGlib.be.translators.df_utils.be_utils.getSpecSliceForUDVSstep">[docs]</a>
<span class="k">def</span> <span class="nf">getSpecSliceForUDVSstep</span><span class="p">(</span><span class="n">h5_udvs_inds</span><span class="p">,</span> <span class="n">udvs_step_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the spectroscopic indices that correspond to the given udvs_step_index</span>
<span class="sd">    that can be used to slice the main data matrix</span>
<span class="sd">    * Developer note - Replace the first parameter with the Raw_Data dataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------------</span>
<span class="sd">    h5_udvs_inds : Reference to HDF5 dataset</span>
<span class="sd">        UDVS_Indices dataset</span>
<span class="sd">    udvs_step_index : unsigned int</span>
<span class="sd">        UDVS step index (base 0)</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    slc : slice object</span>
<span class="sd">        Object containing the start and end indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h5_udvs_inds</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">udvs_step_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">temp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Need to add one additional index otherwise, the last index will be lost</span></div>



<div class="viewcode-block" id="getForExcitWfm">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getForExcitWfm.html#BGlib.be.translators.df_utils.be_utils.getForExcitWfm">[docs]</a>
<span class="k">def</span> <span class="nf">getForExcitWfm</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">h5_other</span><span class="p">,</span> <span class="n">wave_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Slices the provided H5 dataset by the provided wave type.</span>
<span class="sd">    Note that this is applicable to only certain H5 datasets such as the bin frequences, bin FFT etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_main : Reference to HDF5 dataset</span>
<span class="sd">        Raw_Data dataset</span>
<span class="sd">    h5_other :Reference to HDF5 dataset</span>
<span class="sd">        The dataset that needs to be sliced such as bin frequencies</span>
<span class="sd">    wave_type : unsigned int</span>
<span class="sd">        Excitation waveform type</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    freq_vec : 1D numpy array</span>
<span class="sd">        data specific to specified excitation waveform</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">h5_bin_wfm_type</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Bin_Wfm_Type&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h5_bin_wfm_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">wave_type</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">h5_other</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span></div>



<div class="viewcode-block" id="getIndicesforPlotGroup">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.getIndicesforPlotGroup.html#BGlib.be.translators.df_utils.be_utils.getIndicesforPlotGroup">[docs]</a>
<span class="k">def</span> <span class="nf">getIndicesforPlotGroup</span><span class="p">(</span><span class="n">h5_udvs_inds</span><span class="p">,</span> <span class="n">ds_udvs</span><span class="p">,</span> <span class="n">plt_grp_name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For a provided plot group name in the udvs table, this function</span>
<span class="sd">    returns the corresponding spectroscopic indices that can be used to index / slice the main data set</span>
<span class="sd">    and the data within the udvs table for the requested plot group</span>
<span class="sd">    * Developer note - Replace the first parameter with the Raw_Data dataset</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    h5_udvs_inds : Reference to HDF5 dataset</span>
<span class="sd">        containing the UDVS indices</span>
<span class="sd">    ds_udvs : Reference to HDF5 dataset</span>
<span class="sd">        containing the UDVS table</span>
<span class="sd">    plt_grp_name : string</span>
<span class="sd">        name of the plot group in the UDVS table</span>

<span class="sd">    Returns</span>
<span class="sd">    -----------</span>
<span class="sd">    step_bin_indices : 2D numpy array</span>
<span class="sd">        Indices arranged as [step, bin] in the spectroscopic_indices table</span>
<span class="sd">        This is useful for knowing the number of bins and steps in this plot group.</span>
<span class="sd">        We are allowed to assume that the number of bins does NOT change within the plot group</span>
<span class="sd">    oneD_indices : 1D numpy array</span>
<span class="sd">        spectroscopic indices corresponding to the requested plot group</span>
<span class="sd">    udvs_plt_grp_col : 1D numpy array</span>
<span class="sd">        data contained within the udvs table for the requested plot group</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># working on the UDVS table first:</span>
    <span class="c1"># getting the numpy array corresponding the requested plot group</span>
    <span class="n">udvs_col_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ds_udvs</span><span class="p">[</span><span class="n">ds_udvs</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">plt_grp_name</span><span class="p">)])</span>
    <span class="c1"># All UDVS steps that are NOT part of the plot grop are empty cells in the table</span>
    <span class="c1"># and hence assume a nan value.</span>
    <span class="c1"># getting the udvs step indices that belong to this plot group:</span>
    <span class="n">step_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">udvs_col_data</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Getting the values in that plot group that were non NAN</span>
    <span class="n">udvs_plt_grp_col</span> <span class="o">=</span> <span class="n">udvs_col_data</span><span class="p">[</span><span class="n">step_inds</span><span class="p">]</span>

    <span class="c1"># ---------------------------------</span>

    <span class="c1"># Now we use the udvs step indices calculated above to get</span>
    <span class="c1"># the indices in the spectroscopic indices table</span>
    <span class="n">spec_ind_udvs_step_col</span> <span class="o">=</span> <span class="n">h5_udvs_inds</span><span class="p">[</span><span class="n">h5_udvs_inds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;UDVS_Step&#39;</span><span class="p">)]</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spec_ind_udvs_step_col</span> <span class="o">==</span> <span class="n">step_inds</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># Stepehen says that we can assume that the number of bins will NOT change in a plot group</span>
    <span class="n">step_bin_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">step_inds</span><span class="p">),</span> <span class="n">num_bins</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">indx</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">step_inds</span><span class="p">):</span>
        <span class="n">step_bin_indices</span><span class="p">[</span><span class="n">indx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">spec_ind_udvs_step_col</span> <span class="o">==</span> <span class="n">step</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">oneD_indices</span> <span class="o">=</span> <span class="n">step_bin_indices</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">step_bin_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">step_bin_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">step_bin_indices</span><span class="p">,</span> <span class="n">oneD_indices</span><span class="p">,</span> <span class="n">udvs_plt_grp_col</span></div>



<div class="viewcode-block" id="generateTestSpectroscopicData">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.generateTestSpectroscopicData.html#BGlib.be.translators.df_utils.be_utils.generateTestSpectroscopicData">[docs]</a>
<span class="k">def</span> <span class="nf">generateTestSpectroscopicData</span><span class="p">(</span><span class="n">num_bins</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">num_steps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">num_pos</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a (preferably small) test data set using the given parameters.</span>
<span class="sd">    Data is filled with indices (with base 1 for simplicity).</span>
<span class="sd">    Use this for testing reshape operations etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    num_bins : unsigned int (Optional. Default = 7)</span>
<span class="sd">        Number of bins</span>
<span class="sd">    num_steps : unsigned int (Optional. Default = 3)</span>
<span class="sd">        Number of spectroscopic steps</span>
<span class="sd">    num_pos : unsigned int (Optional. Default = 4)</span>
<span class="sd">        Number of fictional positions</span>

<span class="sd">    Returns</span>
<span class="sd">    --------------</span>
<span class="sd">    full_data : 2D numpy array</span>
<span class="sd">        Data organized as [steps x bins, positions]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">full_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_steps</span> <span class="o">*</span> <span class="n">num_bins</span><span class="p">,</span> <span class="n">num_pos</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pos</span><span class="p">):</span>
        <span class="n">bin_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">):</span>
                <span class="n">full_data</span><span class="p">[</span><span class="n">bin_count</span><span class="p">,</span> <span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="p">(</span><span class="n">step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="n">bind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">bin_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">full_data</span></div>



<div class="viewcode-block" id="isSimpleDataset">
<a class="viewcode-back" href="../../../../../_autosummary/BGlib.be.translators.df_utils.be_utils.isSimpleDataset.html#BGlib.be.translators.df_utils.be_utils.isSimpleDataset">[docs]</a>
<span class="k">def</span> <span class="nf">isSimpleDataset</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">isBEPS</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function figures out if a single number defines the bins for all UDVS steps</span>
<span class="sd">    In such cases (udvs_steps x bins, pos) can be reshaped to (bins, positions x steps)</span>
<span class="sd">    for (theoretically) faster computation, especially for large datasets</span>

<span class="sd">    Actually, things are a lot simpler. Only need to check if number of bins for all excitation waveforms are equal</span>

<span class="sd">    Parameters</span>
<span class="sd">    -------------</span>
<span class="sd">    h5_main : Reference to HDF5 dataset</span>
<span class="sd">        Raw_Data dataset</span>
<span class="sd">    isBEPS : Boolean (default = True)</span>
<span class="sd">        Whether or not this dataset is BEPS</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    data_type : Boolean</span>
<span class="sd">        Whether or not this dataset can be unraveled / flattened</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">isBEPS</span><span class="p">:</span>
        <span class="n">beps_modes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;DC modulation mode&#39;</span><span class="p">,</span> <span class="s1">&#39;AC modulation mode with time reversal&#39;</span><span class="p">,</span> <span class="s1">&#39;current mode&#39;</span><span class="p">,</span> <span class="s1">&#39;Relaxation&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">h5_main</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;VS_mode&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">beps_modes</span><span class="p">:</span>
            <span class="c1"># I am pretty sure that AC modulation also is simple</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Could be user defined or some other kind I am not aware of</span>
            <span class="c1"># In many cases, some of these datasets could also potentially be simple datasets</span>
            <span class="n">ds_udvs</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;UDVS&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">excit_wfms</span> <span class="o">=</span> <span class="n">ds_udvs</span><span class="p">[</span><span class="n">ds_udvs</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;wave_mod&#39;</span><span class="p">)]</span>
            <span class="n">wfm_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">excit_wfms</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wfm_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># BEPS with single excitation waveform</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single BEPS excitation waveform&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Multiple waveform types here</span>
                <span class="n">harm_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wfm_types</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">harm_types</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># eg - excitaiton waveforms 1, 2, 3 NOT -1, +1</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="c1"># In this case a single excitation waveform with forward and reverse was used.</span>
                <span class="n">h5_bin_wfm_type</span> <span class="o">=</span> <span class="n">get_auxiliary_datasets</span><span class="p">(</span><span class="n">h5_main</span><span class="p">,</span> <span class="n">aux_dset_name</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Bin_Wfm_Type&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># Now for each wfm type, count number of bins.</span>
                <span class="n">wfm_bin_count</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">wfm</span> <span class="ow">in</span> <span class="n">wfm_types</span><span class="p">:</span>
                    <span class="n">wfm_bin_count</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">h5_bin_wfm_type</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">wfm</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">wfm_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wfm_bin_count</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wfm_lengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># BEPS with multiple excitation waveforms but each excitation waveform has same number of bins</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;All BEPS excitation waves have same number of bins&#39;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># BE-Line</span>
        <span class="k">return</span> <span class="kc">True</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Pycroscopy contributors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>